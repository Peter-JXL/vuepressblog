# 链路层


对于使用广播信道的数据链路层，除了包含这三个问题外，还有一些其他需要解决的问题，如图所示，主机abcde通过一根总线进行互联，主机a要给主机c发送帧，代表帧的信号，会通过总线传输到总线上的其他各主机，那么主机bde如何知道所收到的帧不是发送给他们的，而主题c又如何知道所收到的帧恰恰是发送给自己的，相信大家能够想到地址或者说编制的问题，也就是将帧的目的地址添加在帧中一起传输。

例如这是以太网版本2的MAC帧格式，其手部中的三个字段中有两个字段和地址相关，一个是目的地址字段，另一个是源地址字段。

![image.png](assets/image-20211212102406-rsmpjnh.png)



除了编制问题外，再来看下面这个问题，当总线上多台主机，同时使用总线来传输帧时，传输信号就会产生碰撞，这是采用广播信道的共享式局域网不可避免的。以太网采用的协调方法是使用一种特殊的协议，CSMA/CD，也就是载波监听多点接入/碰撞检测。


随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的需要点对点联络和链路层交换机的交换式局域网，在有线领域已完全取代了共享式局域网，那么网络中的交换机又是如何转发帧的，另外由于无线信道的广播天性，无线局域网仍然使用的是共享信道技术，例如802.11局域网采用的媒体接入控制协议是CSMA/CA，也就是载波监听多点接入/碰撞避免，它的工作原理又是怎样的，上述这些内容都是数据链路层中比较重要的问题



![image.png](assets/image-20211212102614-7ypdur6.png)




## 3.2 封装成帧

‍‍所谓封装成帧就是指数据链路层给上层交付下来的协议数据单元，添加帧头和帧尾，‍‍使之成为帧。

例如下图所示在帧头和帧尾中包含有重要的控制信息，例如‍‍这是以太网版本2的MAC帧格式，这是上层交付下来的协议数据单元，这是帧头，‍‍这是帧尾，这是点对点协议PPP的帧格式，这是上层交付下来的协议数据单元，这是帧头，‍‍这是帧尾。

![image.png](assets/image-20211212102926-19pvyc9.png)


发送方的数据链入层将上层交付下来的协议数据单元封装成帧后，还要通过物理层‍‍将构成帧的个比特转换成电信号，发送到传输媒体。‍‍那么接收方的数据链路层‍‍如何从物理层交付的比特流中提取出一个个的帧呢？例如‍‍这一串比特流是一个帧吗？这一串比特流是一个帧吗？实际上‍‍帧头和帧尾的作用之一就是帧定界。

![image.png](assets/image-20211212103003-nambbcz.png)


例如这是PPP帧的格式，在其帧头和帧尾中‍‍各包含有一个长度为1字节的标志字段，其作用就是帧定界。假设发送方发送的是PPP帧，‍‍比特流中红色部分是帧定界标志，那么接收方的数据链路层就可以依据帧定界标志，‍‍从物理层交付的比特流中提取出一个个的帧

![image.png](assets/image-20211212103054-gbg81f6.png)



需要说明的是‍‍并不是每一种数据链路层协议的帧都包含有帧定界标志。‍‍例如这是以太网版本2的MAC帧格式，‍‍在其帧头和帧尾中并没有包含帧定界标志。那么接收方又是如何从物理层交付的比特流中‍‍提取出一个个的以太网帧？实际上以太网的数据链路层封装好MAC帧后将其交付给物理层，‍‍物理层会在MAC帧前面添加八字节的前导码，然后再将比特流转换成电信号发送‍‍。前导码中的前7个字节为‍‍前同步码，作用是使接收方的时钟同步，之后的1字节为帧开始定界符，‍‍表明其后面紧跟着的就是MAC帧。‍‍

![image.png](assets/image-20211212103236-a0cn1jh.png)


另外以太网还规定了帧间间隔时间为‍‍96比特的发送时间，因此MAC帧并不需要帧结束定界符，需要说明的是‍‍帧间间隔还有其他作用。‍‍我们在后续课程中再进行介绍。


---

接下来我们介绍透明传输的问题，‍‍透明传输是指数据链路层对上层交付的传输数据并没有任何限制，就好像数据链路层不存在一样。‍‍我们来举例说明，这是发送方数据链路层收到其上层交付的协议数据单元，给其添加帧头‍‍和帧尾，使其成为帧。‍‍为了简单起见，我们只画出了帧头和帧尾中的帧定界标志，‍‍帧定界标志也就是一个特定数值。

请大家思考一下，如果在上层交付的协议数据单元中，‍‍恰好也包含了这个特定数值，接收方还能正确接收该帧吗？‍‍回答是否定的。如图所示，接收方在收到第一个帧定界标志时，认为这是帧的开始，‍‍这并没有错误。‍‍当接收方再次接收到帧定界标志时，会误认为帧结束了

![image.png](assets/image-20211212104752-i0e4klv.png)


如果数据链路层不采取其他措施，来避免接收方对帧是否结束的误判，就不能称为透明传输。‍‍也就是说数据链入层对上层交付的协议数据单元有限制，其内容不能包含帧定界符，‍‍很显然这样的数据链路层没有什么使用价值。

实际上各种数据链路层协议一定会想办法来解决这个问题。‍‍例如在发送帧之前，‍‍对帧的数据部分进行扫描，每出现一个帧定界符，就在其前面插入一个转义字符，‍‍接收方数据链路层在物理层交付的比特流装提取帧，遇到第一个帧定界符时，认为这是帧的开始。‍‍当遇到转义字符时就知道其后面的一字节内容虽然与帧定界符相同，但它是数据，‍‍而不是啊定界符。剔除转义字符后，将其后面的内容作为数据继续提取，‍‍对于这个转义字符也是相同的处理。‍‍当再次提取到帧定界符时，表明这是帧的结束。‍‍



请大家再来思考一下这种情况。在上层交付给数据链路层的协议数据单元中，既包含了帧定界符，‍‍又包含了转义字符，应该怎么处理？

方法仍然是在发送帧之前对帧的数据部分进行扫描，‍‍每出现一个帧定界符或转义字符，‍‍就在其前面插入一个转义字符，需要说明的是转义字符是一种特殊的控制字符，‍‍其长度为一个字节，10进制值为27，而并不是E、S以及C这三个字符。‍‍我们刚刚介绍的是面向字节的物理链路，是用字节填充或称字符填充的方法‍‍来实现透明传输。‍‍



对于面向比特的电路，应该使用比特填充的方法来实现透明传输。例如‍‍这是某个点对点协议的帧，‍‍这是帧的数据部分，这是帧的尾部。为了简单起见，在帧手部和尾部中‍‍仅给出了帧定界标志，而未给出其他控制字段，而帧的数据部分出现了两个帧定界标志，‍‍但它们实际上是数据，而不是帧定界。‍‍在发送前可以采用**0比特填充法****，‍‍对数据部分进行扫描，每5个连续的比特1后面就插入1个比特0**，‍‍这样就确保了帧定界在整个帧中的唯一性，也就可以实现透明传输。接收方的数据链路层，‍‍从物理层交付的比特流中提取帧时，将帧的数据部分中的每5个连续的比特1后面的比特0剔除即可。‍‍

![image.png](assets/image-20211212105240-hy1pddg.png)



接下来我们来做一个有关0比特填充的练习题，这是计算机专业考研全国统考‍‍计算机网络部分，2013年的题37

题目中所给的高级数据链路控制协议HDLC‍‍采用帧头和帧尾中的标志字段作为帧定界，旗帜为01111110。‍‍Hdlc为了实现透明传输，采用0比特填充法，也就是每5个连续1后面插入1个比特0‍‍如下所示。因此选项a正确

![image.png](assets/image-20211212105344-qbwkvpf.png)


最后还要提醒大家，为了提高帧的传输效率，‍‍应当使帧的数据部分的长度尽可能大一些。‍‍如图所示帧的数据部分的长度‍‍应远大于帧头和帧尾的程度，这样才能提高帧的传输效率。因为仅层数据链路层来看，‍‍帧的数据部分才是帧正要传输的数据，帧头和帧尾是为了实现数据链路层功能而额外添加的。‍‍当然了，考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，‍‍称为最大传送单元MTU

![image.png](assets/image-20211212105438-r6a2r5f.png)


小结：

![image.png](assets/image-20211212105453-a9uierj.png)




## 3.3 差错检测

我们知道‍‍实际的通信链路都不是理想的，比特在传输过程中可能会产生差错，1可能变成0，‍‍而0也可能变成1，这称为比特差错。如图所示。比特流在传输过程中，‍‍由于受到各种干扰，就可能会出现比特差错或称为误码。‍‍在一段时间内‍‍传输错误的比特占所传输比特总数的比率成为误码率BER。大家可以通过动画演示，‍‍清楚的看到比特在传输过程中出现了错误，但是接收方的数据链路层‍‍又是通过怎样的方法才能知道？

![image.png](assets/image-20211212105801-1te4g3x.png)



使用差错检测码‍‍来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一

例如。‍这是以太网版本2的MAC帧格式，其帧尾中包含了一个长度为4字节的帧检验序列FCS字段，‍‍其作用就是让接收方的数据链路层检查帧在传输过程中是否产生了误码，‍‍这是点对点协议PPP的帧格式，其帧尾中也包含了一个长度为两字节的帧检验序列，‍‍FCS字段，其作用也是让接收方的数据链路层检查正在传输过程中是否产生了误码。

![image.png](assets/image-20211212105914-v96khnq.png)


### 奇偶校验

接下来‍‍我们介绍奇偶校验这种比较简单的检测方法，在待发送的数据后面添加一位奇偶校验位，‍‍使整个数据包括所添加的校验位在内中的1的个数为基数这称为基教验，或为偶数这称为偶校验。‍‍我们来举例说明，这是待发送的数据，假设收发双方约定采用基校验，‍‍那么在数据后面添加的校验位应该为比特1，使得比特一的总数为基数，‍‍假设传输过程中产生了一位误码，我们用红色表示，接收方对收到的比特流进行基校验，‍‍发现比特1的总数为偶数而不是基数，就知道传输过程中发生了误码。‍‍

![image.png](assets/image-20211212110154-ta5pwxr.png)


* 换句话说，‍‍采用基校验，若比特1的数量的基性改变，可以检查出错误，但是‍‍如果传输过程中产生了两位误码，接收方对收到的比特流进行机校验，‍‍发现比特1的总数为基数，就误认为传输过程中没有发生误码。换句话说，采用基校验，‍‍若比特1的数量的奇性不改变，是无法检查出错误的。‍‍
* 假设收发双方约定采用偶校验，‍‍那么在数据后面添加的校验位应该为比特0，使得比特1的总数为偶数，‍‍假设传输过程中产生了1位误码，接收方对收到的比特流进行偶校验，‍‍发现比特1的总数为基数而不是偶数，就知道传输过程中发生了误码。换句话说，采用偶校验‍‍若比特1的数量的偶性改变，可以检查出错误，但是如果传输过程中产生了两位误码，接收方对收到的比特流进行偶校验，发现比特1的总数为偶数，‍‍就误认为传输过程中没有发生误码。换句话说，采用偶校验，若比特1的数量的偶性不改变，‍‍是无法检查出错误的。‍‍

通过本例可以看出采用奇偶校验，如果有奇数个位发生误码，则奇偶性会发生变化，也就是奇变偶者是偶变奇，这样就可以检查出误码。而如果有偶数各位发生误码，则奇偶性不会发生变化，‍‍这是因为每个误码对奇偶性的影响相互抵消了，这样就要无法检查出误码，也称为漏检。‍‍**由于奇偶校验的漏检率比较高，因此计算机网络的数据链路层一般不会采用这种检测方法**。‍‍


### 循环冗余校验CRC

接下来我们介绍循环冗余校验CRC，这是一种具有很强检测能力的检测方法，漏检率极低：

* 收发双方约定好一个生成多项式
* 发送方基于代发送的数据和生成多项式计算出差错检测码，称为冗余码，‍‍并将其添加到带传输数据的后面一起传输。
* 接收方通过生成多项式来计算‍‍收到的数据是否产生了误码。


我们来看发送方的操作，是用除法来计算冗余吗，待发送的数据作为被除数的一部分，后面添加生成多项式最高次数个0，已构成被除数，‍‍生成多项式各项系数构成的比特串作为除数进行除法，得到商‍‍和余数，余数就是所计算出的冗余码，将其添加到待发送数据的后面一起发送。‍‍需要注意的是‍‍冗余码的长度与生成多项式最高次数相同，而商仅作为标记，防止计算过程中对错位。‍‍

再来看接收方的处理，也是做除法，被除数就是接收到的数据，‍‍除数仍是生成多项式各项系数构成的比特串，进行除法，得到商和余数。‍‍如果余数为0，‍‍可判定传输过程没有产生误码，否则可判定传输过程产生了误码。‍‍

![image.png](assets/image-20211212110801-529g1wt.png)


下面‍‍我们对生成多项式举例说明，这是一个生成多项式，这是该生成多项式的完整形式，‍‍生成多项式各项系数构成的比特串，就是我们做除法时所用到的除数，‍‍这是常用的生成多项式，使用这些生成多项式进行crc校验，可以达到较好的检测效果，‍‍也就是漏检率比较低。需要注意的是crc，算法要求生成多项式，必须包含最低次项。‍‍

![image.png](assets/image-20211212110855-wdmqwkw.png)