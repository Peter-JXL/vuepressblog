---
title: classpath：JVM查找类的机制
date: 2022-11-21 21:26:13
permalink: /JavaSE/classpath/
categories:
  - Java
  - Java基础
tags:
  - 
---
# classpath：JVM查找类的机制

　　本文主要是参考廖雪峰老师的博客，自己动手实践而得，感谢：

　　[包 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976)

　　[classpath和jar - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296)

　　[Java入门实例classpath及package详解 - 橘子山寨 - BlogJava](http://www.blogjava.net/agassi-p/archive/2006/11/27/83764.html)

　　‍

## 编译一个类

　　还记得我们的第一个Java程序吗？我们新建了一个目录，然后创建了Hello.java文件，编写代码：

```Java
public class Hello{
    public static void main(String[] args){
        System.out.println("Welcome to Java!");
    }
}
```

　　我们这里假设新目录为D:\JavaTest

　　‍

　　然后我们在文件所在目录，打开命令行，将Java 源文件翻译成 Java字节码文件并执行：

```
D:\JavaTest> javac Hello.java
D:\JavaTest> java Hello      
Welcome to Java!
```

　　‍

　　我们目前是直接在存放源码的文件夹中进行编译和运行的，一些重要的问题没有暴露出来：

1. 操作系统如何寻找 `javac`​ 和  `java`​命令？ 答：由于`javac`​ 和  `java`​命令是可执行文件，操作系统会根据我们安装Java的时候配置的path去寻找这两个文件；
2. 操作系统如何寻找 Hello.java 和 Hello.class文件？此时，就不是根据我们安装Java时的path变量去寻找了，到底如何查找呢？我们一步步测试并分析。

　　‍

　　我们将命令行所在目录回退到上一级，此时，当前路径就不是源码存放的路径了，然后我们输入`javac`​命令：

```java
D:\> javac Hello.java
javac: 找不到文件: Hello.java
用法: javac <options> <source files>
-help 用于列出可能的选项
```

　　有报错找不到文件，这很正常，因为源码不在当前路径下。我们需要指定一个路径：

```java
D:\> javac D:\JavaTest\Hello.java
```

　　这回不报错了，编译成功。

　　‍

　　‍

　　接下来我们尝试执行：

```java
D:\> java D:\JavaTest\Hello
错误: 找不到或无法加载主类 D:\JavaTest\Hello
```

　　明明`01.Hello/Hello`​ 是一个class文件，为什么就找不到了呢？

　　原来，Java对待​`.java`​​文件与​`.class`​​文件是有区别的。对.java文件可以直接指定路径给它，而java命令所需的.class文件不能出现扩展名，也不能指定额外的路径给它。​请牢记这一点。

　　那么，对于Java所需的 `.class`​文件，如何指定路径呢？必须通过classpath来指定。​

　　‍

　　我们配置一个新的环境变量。首先打开环境变量窗口，然后在用户变量中新建一个变量，变量名为 classpath，变量值为 D:\JavaTest

　　重新打开一个新的cmd，输入`java Hello`​

```java
C:\WINDOWS\system32> java Hello
Welcome to Java!
```

　　可以看到，即使我们不在源码所在目录，也能运行Java程序；由此可见，classpath环境变量的作用就是告诉JDK去哪里寻找 .class文件。一旦设置了classpath变量，以后每次运行java或javac命令时，如果要查找.class文件，都会去classpath里找。这是一个全局的设置。

　　‍

　　如果有新程序就设置classpath变量，那么也太麻烦了，我们可以在运行Java程序的时候指定一个classpath：

```java
D:\> java -classpath D:/JavaTest Hello
Welcome to Java!
```

　　JDK发现有classpath选项后，就会先根据此classpath指定的路径寻找 `.class`​文件，找不到再去全局的classpath环境变量中寻找。我们可以试着删除环境变量，打开一个新的CMD，然后再次执行上述命令。

　　‍

> tips: 可以用classpath的缩写cp来代替，如下：
>
> ```java
> D:\> java -cp D:/JavaTest Hello
> Welcome to Java!
> ```
>
> 1.特别注意的是，JDK 1.5.0之前，javac命令不能用cp来代替classpath，而只能用classpath
>
> 如果`.class`​文件路径带有空格，需要加上双引号，例如
>
> ```java
> javac "D:\Java Test\Hello.java"
> java -classpath "D:\Java Test" Hello
> ```
>
> 请自行尝试有空格的情况。

　　‍

　　‍

　　‍

　　‍

　　‍

　　‍

　　‍

　　‍

## 编译多个类

　　当我们编译的类里面，包含其他类的时候，该怎么编译呢？我们举个例子：

　　在Hello.java的同级目录下新建一个Person.java

```java
public class Person {
  private String name;
  public Person (String name){
    this.name = name;
  }

  public String getName() {
    return name;
  }
}
```

　　修改Hello.java

```java
public class Hello{
  public static void main(String[] args){
    Person person = new Person("Peter");
      System.out.println(person.getName());
  }
}

```

　　‍

　　接下来，我们尝试编译

```java
D:\> javac D:/JavaTest/Hello.java
D:\JavaTest\Hello.java:3: 错误: 找不到符号
    Person person = new Person("Peter");
    ^
  符号:   类 Person
  位置: 类 Hello
D:\JavaTest\Hello.java:3: 错误: 找不到符号
    Person person = new Person("Peter");
                        ^
  符号:   类 Person
  位置: 类 Hello
2 个错误
```

　　此时我们可以看到JDK报错找不到Person类。为什么之前可以通过指定源码的路径，来编译，现在不行呢？因为之前的Hello类中没有用到其他类，因此JDK不需要去寻找其他类；

　　而现在，我们用到了Person类，我们就得告诉JDK，去哪里找这个类（即使他们在同一个文件夹下）

```java
D:\> javac -cp D:/JavaTest D:/JavaTest/Hello.java
```

　　编译通过，可以看到生成了Person.class文件。

　　实际上由于Hello.java使用了Person.java类，JDK先编译生成了Person.class，然后再编译生成Hello.class。因此，不管Hello.java这个主类使用了多少个其他类，只要编译这个类，JDK就会自动编译其他类，很方便。

　　我们尝试运行：

```java
D:\> java -cp D:/JavaTest Hello
Peter
```

　　‍

　　‍

## 多个classpath

　　接下来我们试试，源码在不同目录的情况。

　　我们在01.Hello文件夹下新建一个名为lib的文件夹，将Person.java 移动到其下面，并删除Person.class文件。

　　我们尝试编译：

```java
D:\> javac -cp D:/JavaTest/lib D:/JavaTest/Hello.java
```

　　编译通过，因为Person在lib文件夹里，我们只需修改classpath为lib文件夹的目录即可

　　‍

　　我们尝试运行：

```java
D:\> java -cp D:/JavaTest Hello
Exception in thread "main" java.lang.NoClassDefFoundError: Person
        at Hello.main(Hello.java:3)
Caused by: java.lang.ClassNotFoundException: Person
        at java.net.URLClassLoader.findClass(Unknown Source)
        at java.lang.ClassLoader.loadClass(Unknown Source)
        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
        at java.lang.ClassLoader.loadClass(Unknown Source)
        ... 1 more
```

　　有报错，因为我们没有指定Person的路径，有报错也是正常的。我们尝试指定：

```java
D:\> java -cp D:/JavaTest/lib Hello
错误: 找不到或无法加载主类 Hello
```

　　还是有报错。。。为什么呢？

　　由于Java需要在不同文件夹下寻找class文件，而classpath只告诉了JDK一个路径，有错误也是正常的。

> 在本文的一开始，我们在编译一个类的时候，为什么不用指定classpath也能运行呢？因为默认JVM会从当前路径寻找类，如果指定了classpath，就不从当前路径寻找了。

　　‍

　　‍

　　‍

　　此时我们需要设置多个classpath，以分号 “；”隔开（注意路径与分号之间不能有空格）：

```java
D:\> java -classpath "D:\JavaTest;D:\JavaTest\lib" Hello
Peter
```

　　运行成功，但也暴露出一个问题，如果我们需要用到许多分处于不同文件夹下的类，那这个classpath的设置岂不是很长！有没有办法，对于一个文件夹下的所有.class文件，只指定这个文件夹的classpath，然后让JDK自动搜索此文件夹下面所有相应的路径？有，只要使用package，且听下回分解。

　　‍

　　‍

　　‍

　　注意：请自己独立完成上述实验过程，如果有问题再好好看看该博客，以确保确实掌握了classpath的概念和使用。

　　‍
