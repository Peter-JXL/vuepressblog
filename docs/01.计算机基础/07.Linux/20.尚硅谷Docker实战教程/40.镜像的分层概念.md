---
title: 镜像的分层概念
date: 2023-09-18 11:06:13
permalink: /Docker/Image-layering-concept/
categories:
  - 计算机基础
  - Linux
  - 尚硅谷Docker实战教程
tags:
  - 
---
# 40.镜像的分层概念

　　来更深入地理解镜像的概念
<!-- more -->
　　‍

## 镜像的分层

　　镜像，是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。

　　只有通过这个镜像文件才能生成Docker容器实例（类似Java中new出来一个对象）。

　　‍

　　那什么是分层呢？先来看一个现象，在下载Tomcat镜像的时候，好像是在一层一层的在下载：

```shell
$ docker pull tomcat
Using default tag: latest
latest: Pulling from library/tomcat
0e29546d541c: Pull complete 
9b829c73b52b: Pull complete 
cb5b7ae36172: Pull complete 
6494e4811622: Pull complete 
668f6fcc5fa5: Pull complete 
dc120c3e0290: Pull complete 
8f7c0eebb7b1: Downloading [=======================>                           ]  96.69MB/203.1MB
77b694f83996: Download complete 
0f611256ec3a: Download complete 
4f25def12f23: Download complete 
```

　　‍

　　这是因为镜像文件，是分层的，基于UnionFS。

　　UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像，类似Java中的Object类，是所有类的父类），可以制作各种具体的应用镜像。

　　特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录

　　‍

## 镜像加载原理

　　 镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。

　　bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。

　　rootfs（root file system）， 在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。

　　![](https://image.peterjxl.com/blog/image-20230902114947-aqn85lu.png)

　　‍

　　

　　平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？

　　对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。

　　比如，启动一个Ubuntu，进入到容器后，会发现vim等工具都是没有的

　　‍

## 为什么要用分层结构

　　镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。

　　比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；

　　同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。

　　例如，想要在一个Ubuntu镜像上添加一个vim功能，作为一个新的镜像，此时就用Ubuntu镜像上添加vim即可，不用自己从头搭建一个镜像。

　　‍

　　‍

　　重点理解：Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。

　　![](https://image.peterjxl.com/blog/image-20230902205528-4vnbcpm.png)

　　所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。

　　‍

## Docker镜像commit操作案例

　　接下来我们试着给Ubuntu添加vim功能，然后封装其为一个新的镜像。此时就可以用都Docker的commit命令，格式：

```shell
docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]
```

　　‍

　　‍

　　先启动一个Ubuntu，然后安装vim（安装时间可能会比较久）：

```shell
$ docker run -it ubuntu
$ apt-get update
$ apt-get -y install vim
```

　　‍

　　‍

　　安装vim后，退出Ubuntu，然后根据命令格式使用docker commit，使之成为一个新镜像：

```shell
$ docker ps -a
CONTAINER ID   IMAGE     COMMAND  CREATED          STATUS       
b76722ca3c37   ubuntu    "bash"  18 minutes ago   Exited (0) 21 seconds ago 

$ docker commit -m="add vim" -a="peterjxl"  b76722ca3c37 peterjxl/myubuntu:1.1
```

　　‍

　　‍

　　可以看到新镜像比原本的Ubuntu大了不少：

```shell
$ docker images
REPOSITORY          TAG       IMAGE ID       CREATED         SIZE
peterjxl/myubuntu   1.1       0d0cf3b0417f   6 seconds ago   187MB
ubuntu              latest    ba6acccedd29   22 months ago   72.8MB
```

　　‍

　　‍

　　并且使用该镜像创建一个该容器，也能有vim命令：

```shell
$ docker run -it 0d0cf3b0417f

$ vim -version
VIM - Vi IMproved 8.1 (2018 May 18, compiled Aug 18 2023 03:41:54)
Garbage after option argument: "-version"
More info with: "vim -h"
```

　　‍

　　‍

## 总结

　　Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。

　　新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层

　　![](https://image.peterjxl.com/blog/image-20230902211242-je8pkf5.png)
