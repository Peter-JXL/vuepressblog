---
title: 分布式存储之哈希取余算法
date: 2023-09-18 11:06:13
permalink: /Docker/distributed-storage-hash-remainder/
categories:
  - 计算机基础
  - Linux
  - 尚硅谷Docker实战教程
tags:
  - 
---
# 100.分布式存储之哈希取余算法

　　本文讲讲大厂面试题第四季-分布式存储案例，例如用Redis集群（3主3从）情况下，如何存储亿级数据。
<!-- more -->
　　‍

## 分析

　　首先，单机单台100%不可能，肯定是分布式存储。

　　该问题是阿里P6~P7工程案例和场景设计类必考题目， 一般业界有3种解决方案：

* 哈希取余分区
* 一致性哈希算法分区
* 哈希槽分区

> 从上往下，复杂度越来越高

　　‍

　　‍

　　‍

　　‍

## 哈希取余分区

　　​![](https://image.peterjxl.com/blog/image-20230907111759-6q60b63.png)​

　　原理：2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。

　　‍

　　优点：简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。

　　‍

　　缺点：原来规划好的节点，进行扩容或者缩容就比较麻烦了，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：`Hash(key)/3`​会变成`Hash(key) /?`​，此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。

　　某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。

　　‍

　　‍

## 一致性哈希算法分区

　　‍

　　背景：一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，取余就不好用了

　　原理：提出一致性Hash解决方案，当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。

　　步骤：

* 构建一致性哈希环
* 服务器IP节点映射
* key落到服务器的落键规则

　　‍

　　‍

### 一致性哈希环

　　 一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法能算出来的所有哈希值会构成一个全量集。

　　这个集合可以称之为一个hash空间  [0,2^32^-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连，这样让它逻辑上形成了一个环形空间。

　　​![](https://image.peterjxl.com/blog/wps7-20230907112227-qcchpwf.png)

　　​

　　之前我们是对节点（服务器）的数量进行取模，而一致性Hash算法是对2^32^取模。

　　整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32^-1，也就是说0点左侧的第一个点代表2^32^-1，我们把这个由2^32^个点组成的圆环称为Hash环。

　　​​

### 服务器IP节点映射

　　接下来将集群中各个IP节点映射到环上的某一个位置。将各个服务器使用Hash进行一个计算，具体可以选择服务器的IP或主机名作为关键字进行计算，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算`(hash(ip))`​，使用IP地址哈希后在环空间的位置如下：

　　​![](https://image.peterjxl.com/blog/wps8-20230907112227-5qbjcru.png)

　　​

### key落到服务器的落键规则

　　当我们需要存储一个kv键值对时，首先计算key的hash值，算出哈希值并确定此数据在环上的位置，**从此位置沿环顺时针“行走”**，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。

　　如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。

　　​![](https://image.peterjxl.com/blog/wps9-20230907112227-i7ey3fk.png)​

### 优点

　　解决了容错性和扩展性的问题。

　　‍

　　**容错性：**假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。

　　​![](https://image.peterjxl.com/blog/wps10-20230907112227-cga1eru.png)​

　　‍

　　 扩展性：数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。

　　​![](https://image.peterjxl.com/blog/wps11-20230907112227-9ap16tn.png)

　　​

### 缺点

　　Hash环的数据倾斜问题：一致性Hash算法在服务**节点太少时**，容易因为节点分布不均匀而造成**数据倾斜**（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器：

　　 ![](https://image.peterjxl.com/blog/wps12-20230907112227-bostpva.png)

　　‍

### 小结

　　为了在节点数目发生改变时尽可能少的迁移数据，将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。

　　而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。

　　优点：加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。

　　缺点：数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。

　　‍

## 哈希槽分区

> 常用，需掌握

　　‍

### 概述

　　哈希槽分区，解决了一致性哈希算法的数据倾斜问题。哈希槽实质就是一个数组 [0,2^14 ​^-1] 形成hash slot空间

　　为了解决倾斜的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。（有点像代理模式）

　　​![](https://image.peterjxl.com/blog/wps18-20230907112318-lfjhq7u.png)​

　　槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。

　　哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。

　　‍

　　多少个hash槽？

　　一个集群只能有16384个槽，编号0-16383 （也就是0 ~2^14^-1）。

> Redis也是用的哈希槽，具体的可以看尚硅谷的大厂学苑-Redis专题，这里不展开

　　将由这些槽决定数据如何分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个节点，集群会记录节点和槽的对应关系。

　　解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几，key就落入对应的槽里。`slot = CRC16(key) % 16384`​。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。

　　‍

### 哈希槽计算

　　Redis 集群中内置了 16384 个哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，Redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。

　　​![](https://image.peterjxl.com/blog/wps19-20230907112318-tcd4lfy.png)

　　‍

　　‍

　　如下代码，key之A 、B在Node2， key之C落在Node3上

```Java
@Test
public void test() {
    // import io.lettuce.core.cluster.SlotHash
    System.out.println(SlotHash.getSlot("A")); //6373
    System.out.println(SlotHash.getSlot("B")); //10374
    System.out.println(SlotHash.getSlot("C")); //14503
    System.out.println(SlotHash.getSlot("hello")); //866
}
```

　　‍

　　​

　　接下来就是实操，搭建Redis集群

　　(完)
