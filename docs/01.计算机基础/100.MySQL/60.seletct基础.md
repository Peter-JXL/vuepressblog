---
title: seletct基础
date: 2024-01-21 22:35:19
permalink: /pages/369617/
categories:
  - 计算机基础
  - MySQL
tags:
  - 
---
# 60.seletct基础

　　接下来我们使用`SELECT`语句来查询之前创建的Product表。`SELECT` 语句是 SQL 最基本也是最重要的语句，掌握了 SELECT 语句，距离掌握 SQL 语句就不远了。请务必亲自动手实践。

　　‍

　　‍

　　‍

## 查询指定列

　　从表中选取数据时需要使用 SELECT 语句 ，通过 SELECT 语句查询并选取出必要数据的过程称为匹配查询或查询 （query）。

　　‍

　　SELECT 语句的基本语法如下所示：

```SQL
SELECT <列名>，……
 FROM <表名>；
```

　　该SQL包含了 SELECT 和 FROM 两个子句 （clause）。子句是 SQL 语句的组成要素，是以 SELECT 或者 FROM 等作为起始的短语。

　　SELECT 子句中列举了希望从表中查询出的列的名称，查询多列时，需要使用逗号进行分隔。而 FROM 子句则指定了选取出数据的表的名称。

　　‍

　　‍

　　接下来，我们尝试从Product表中，查询出 product_id （商品编号）列、product_name （商品名称）列和 purchase_price （进货单价）列：

```sql
SELECT product_id, product_name, purchase_price
  FROM Product;

```

　　‍

　　执行结果：

```sql
mysql> SELECT product_id, product_name, purchase_price
    ->   FROM Product;
+------------+--------------+----------------+
| product_id | product_name | purchase_price |
+------------+--------------+----------------+
| 0001       | T恤衫        |            500 |
| 0002       | 打孔器       |            320 |
| 0003       | 运动T恤      |           2800 |
| 0004       | 菜刀         |           2800 |
| 0005       | 高压锅       |           5000 |
| 0006       | 叉子         |           NULL |
| 0007       | 擦菜板       |            790 |
| 0008       | 圆珠笔       |           NULL |
+------------+--------------+----------------+
8 rows in set (0.00 sec)
```

　　‍

　　可以看到，查询结果中列的顺序和 SELECT 子句中的顺序相同。

　　‍

　　‍

## 查询所有列

　　想要查询出全部列时，可以使用代表所有列的星号（* ） 。语法：

```sql
SELECT *
  FROM <表名>;
```

　　使用星号的话，就无法设定列的显示顺序了。这时就会按照 CREATE TABLE 语句的定义对列进行排序。

　　‍

　　例如查询Product表中的全部列：

```sql
SELECT *
  FROM Product;
```

　　‍

　　执行结果：

```sql
mysql> SELECT * FROM Product;
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |        100 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+
8 rows in set (0.00 sec)
```

　　‍

## 指定列别名

　　SQL 语句可以使用 AS 关键字 为列设定别名：

```sql
SELECT product_id     AS id,
       product_name   AS name,
       purchase_price AS price
  FROM Product;
```

　　‍

　　执行结果：

```sql
+------+---------+-------+
| id   | name    | price |
+------+---------+-------+
| 0001 | T恤衫   |   500 |
| 0002 | 打孔器  |   320 |
| 0003 | 运动T恤 |  2800 |
| 0004 | 菜刀    |  2800 |
| 0005 | 高压锅  |  5000 |
| 0006 | 叉子    |  NULL |
| 0007 | 擦菜板  |   790 |
| 0008 | 圆珠笔  |  NULL |
+------+---------+-------+
8 rows in set (0.00 sec)
```

　　‍

　　别名可以使用中文，使用中文时需要用双引号（" ） 括起来 。使用双引号可以设定包含空格（空白）的别名。但是如果忘记使用双引号就可能出错，因此并不推荐。大家可以像 product_list 这样使用下划线（_）来代替空白。

```sql
mysql> SELECT product_id     AS "商品编号",
    ->        product_name   AS "商品名称",
    ->        purchase_price AS "进货单价"
    ->   FROM Product;
+----------+----------+----------+
| 商品编号 | 商品名称 | 进货单价 |
+----------+----------+----------+
| 0001     | T恤衫    |      500 |
| 0002     | 打孔器   |      320 |
| 0003     | 运动T恤  |     2800 |
| 0004     | 菜刀     |     2800 |
| 0005     | 高压锅   |     5000 |
| 0006     | 叉子     |     NULL |
| 0007     | 擦菜板   |      790 |
| 0008     | 圆珠笔   |     NULL |
+----------+----------+----------+
8 rows in set (0.00 sec)
```

　　‍

　　像这样使用别名可以让 SELECT 语句的执行结果更加容易理解和操作。

> 注意，Oracle中不能使用as，上述SQL中直接去掉as即可，会自动将列名后的内容当作别名

　　‍

## 查询常数

　　SELECT 子句中不仅可以书写列名，还可以书写常数。写了常数有什么用呢？相当于为结果添加一列，例如：

```sql
mysql> SELECT '商品' AS string, 38 AS number, '2009-02-24' AS date,
    ->        product_id, product_name
    ->   FROM Product;
+--------+--------+------------+------------+--------------+
| string | number | date       | product_id | product_name |
+--------+--------+------------+------------+--------------+
| 商品   |     38 | 2009-02-24 | 0001       | T恤衫        |
| 商品   |     38 | 2009-02-24 | 0002       | 打孔器       |
| 商品   |     38 | 2009-02-24 | 0003       | 运动T恤      |
| 商品   |     38 | 2009-02-24 | 0004       | 菜刀         |
| 商品   |     38 | 2009-02-24 | 0005       | 高压锅       |
| 商品   |     38 | 2009-02-24 | 0006       | 叉子         |
| 商品   |     38 | 2009-02-24 | 0007       | 擦菜板       |
| 商品   |     38 | 2009-02-24 | 0008       | 圆珠笔       |
+--------+--------+------------+------------+--------------+
8 rows in set (0.00 sec)
```

　　可以看到查询结果多了我们指定的列。一般来说直接书写常数用的较少

　　‍

　　‍

　　‍

## 查询时去除重复行

　　想知道Product 表中保存了哪些商品种类（product_type ），要怎么做呢？方法一是直接查询，然后从结果中去除重复行：

```sql
select product_type from Product;
+--------------+
| product_type |
+--------------+
| 衣服         |
| 办公用品     |
| 衣服         |
| 厨房用具     |
| 厨房用具     |
| 厨房用具     |
| 厨房用具     |
| 办公用品     |
+--------------+
8 rows in set (0.00 sec)
```

　　‍

　　‍

　　或者我们使用DISTINCT关键字来删除重复行：

```sql
mysql> SELECT DISTINCT product_type FROM Product;
+--------------+
| product_type |
+--------------+
| 衣服         |
| 办公用品     |
| 厨房用具     |
+--------------+
3 rows in set (0.00 sec)
```

　　‍

　　‍

　　在使用 DISTINCT 时，NULL 也被视为一类数据。NULL 存在于多行中时，也会被合并为一条 NULL 数据。例如商品价格有2个为空，查询结果：

```sql
mysql> SELECT DISTINCT purchase_price FROM Product;3
+----------------+
| purchase_price |
+----------------+
|            500 |
|            320 |
|           2800 |
|           5000 |
|           NULL |
|            790 |
+----------------+
6 rows in set (0.00 sec)
```

　　‍

　　DISTINCT 也可以在多列之前使用。此时，会将多个列的数据进行组合，将重复的数据合并为一条。例如：

```sql
mysql> SELECT DISTINCT product_type, regist_date
    ->   FROM Product;
+--------------+-------------+
| product_type | regist_date |
+--------------+-------------+
| 衣服         | 2009-09-20  |
| 办公用品     | 2009-09-11  |
| 衣服         | NULL        |
| 厨房用具     | 2009-09-20  |
| 厨房用具     | 2009-01-15  |
| 厨房用具     | 2008-04-28  |
| 办公用品     | 2009-11-11  |
+--------------+-------------+
7 rows in set (0.00 sec)
```

　　‍

　　product_type 列为 '厨房用具' ，同时 regist_date 列为 '2009-09-20' 的两条数据被合并成了一条。

　　注意：DISTINCT 关键字只能用在第一个列名之前 。因此，请大家注意不能写成 regist_date, DISTINCT product_type 。

　　‍

　　‍

　　‍

　　‍

　　‍

　　‍

## 根据条件查询

　　有时候我们不想查询全部数据。而是想查询部分数据，例如“商品种类为衣服”“销售单价在 1000 日元以上”等条件的数据，那么此时就可以用where关键字。

　　在 WHERE 子句中可以指定“某一列的值和这个字符串相等”或者“某一列的值大于这个数字”等条件。执行含有这些条件的 SELECT 语句，就可以查询出只符合该条件的记录了

> 这和 Excel 中根据过滤条件对行进行过滤的功能是相同的。

　　‍

　　语法：

```sql
SELECT <列名>, ……
  FROM <表名>
 WHERE <条件表达式>;
```

　　‍

　　例如，选取product_type 列为'衣服'的数据：

```sql
mysql> select product_name, product_type
    ->   from Product
    ->  where product_type = '衣服';
+--------------+--------------+
| product_name | product_type |
+--------------+--------------+
| T恤衫        | 衣服         |
| 运动T恤      | 衣服         |
+--------------+--------------+
2 rows in set (0.00 sec)
```

　　‍

　　WHERE 子句中的“product_type = '衣服' ”就是用来表示查询条件的表达式（条件表达式 ）。等号是比较两边的内容是否相等的符号，上述条件就是将 product_type 列的值和 '衣服' 进行比较，判断是否相等。Product 表的所有记录都会被进行比较。

　　‍

　　执行的过程是这样的：先通过where子句查询出符合指定条件的记录，然后再通过select选出指定的列：

　　![00040](https://image.peterjxl.com/blog/Image00040-20230920114401-wgwlf9e.jpg)

　　‍

　　‍

　　注意：SQL 中子句的书写顺序是固定的，不能随意更改 。where 子句必须紧跟在 from 子句之后，书写顺序发生改变的话会造成执行错误。

　　‍

　　‍

## 注释的写法

　　注释是 SQL 语句中用来标识说明或者注意事项的部分，提高可读性，对 SQL 的执行没有任何影响。因此，无论是英文字母还是汉字都可以随意使用。

　　注释分为行注释和多行注释

　　‍

　　行注释：书写在“-- ”之后（注意--后面有个空格），只能写在同一行。例如：

```sql
-- 本SELECT语句会从结果中删除重复行。
SELECT DISTINCT product_id, purchase_price
  FROM Product;
```

　　‍

　　多行注释：书写在“` /* `”和“ `*/` ”之间，可以跨多行。例如：

```sql
/* 本SELECT语句，
   会从结果中删除重复行。*/
SELECT DISTINCT product_id, purchase_price
  FROM Product;
```

　　‍

　　甚至在SQL语句内部也可以用注释：

```sql
select *
-- 注释
from Product;
```

　　‍

　　注释能够帮助阅读者更好地理解 SQL 语句，特别是在书写复杂的 SQL 语句时，希望大家能够尽量多加简明易懂的注释。注释没有长度限制，写多少都行

　　‍

　　‍

　　（完）
