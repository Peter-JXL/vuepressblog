---
title: 5.6 TCP超时重传时间的选择
date: 2023-11-16 15:51:58
permalink: /Network/Transport-layer/5.6
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-B站教书匠
tags:
  - 
---

　　‍

## 5.6 TCP超时重传时间的选择

　　本节课我们介绍TCP超时重传时间的选择
<!-- more -->

　　超时重传时间的选择是TCP最复杂的问题之一。我们来举例说明，假设主机A和B是因特网上的两台主机，他们之间已经建立了TCP连接，纵坐标为时间，现在主机A给主机B发送TCP数据报文段0，并记录下当前的时间。主机B收到后给主机A发送相应的确认报文段。主机A收到确认报文段后，记录下当前的时间，那么主机A记录下的这两个时间，它们的差值，就是报文段的往返时间RTT由于这是第0个报文段的RTT，我们就用RTT0来表示。试想一下，如果我们将超时重穿时间，RTO的值设置的比RTT0的值小，会出现怎样的情况？很显然这会引起报文段不必要的重传，使网络负荷增大。

　　‍

　　![](https://image.peterjxl.com/blog/image-20211219110853-n2lzkwb.png)

　　‍

　　‍

　　那么如果将超时重传时间，RTO的值设置的远大于RTT0的值，又会出现怎样的情况？很显然这会使重传推迟的时间太长，使网络的空闲时间增大，降低了传输效率。

　　![](https://image.peterjxl.com/blog/image-20211219110942-fmotrxa.png)

　　‍

　　综合上述两种情况，我们可以得出这样的结论，超时重传时间RTO的值应该设置为略大于报文段往返时间RTT的值。至此同学们可能会觉得超时重传时间的选择也并不是很复杂，然而 TCP下层是复杂的互联网环境，主机A所发送的报文段可能只经过一个高速率的局域网，也有可能经过多个低速率的网络，并且每个IP数据报的转发路由还可能不同。

　　‍

　　‍

　　‍

　　例如现在主机A给主机B发送TCP数据报文段一，主机B收到后，给主机A发送相应的确认报文段，主机A这次测得的报文段往返时间RTT一如图所示，显然RTT1远大于RTT0，如果超时重装时间RTO还是我们之前所确定的略大于RTT0的话，这对于数据报文段1是不合适的，会造成该报文段不必要的重传。

　　![](https://image.peterjxl.com/blog/image-20211219111049-tw60dlm.png)

　　‍

　　‍

　　这样看来超时重传时间的选择确实不那么简单了，我们不能直接使用某次测量得到的RTT样本来计算超时重装时间RTO，但是我们可以利用每次测量得到的RTT样本，计算加权平均往返时间RTTS，这样可以得到比较平滑的往返时间。当测量到第一个RTT样本时，RTTS的值直接取为第一个RTT样本的值，以后每测量到一个RTT样本时，都按该公式来计算新的RTT S值。

　　在上式中阿尔法的取值大于等于0，且小于一，若阿尔法很接近于零，则新RTT样本对RTTS的影响不大，若阿尔法很接近于一则新RTT样本，对RTTS的影响较大，已成为建议标准的RFC6298，推荐的阿尔法值为1/8，即0.125，用这种方法得出的加权平均往返时间RTTS的值就要比测量出的RTT的值更加平滑。  
显然超时重穿时间，RTO的值应略大于加权平均往返时间RTTS的值。

　　![](https://image.peterjxl.com/blog/image-20211219111232-x3nhq4m.png)

　　‍

　　下面我们给出RFC6298建议使用的超时重传时间RTO的计算公式，该公式中的RTTS是加权平均往返时间，我们刚刚介绍过它的计算方法，RTTD是RTT偏差的加权平均，计算方法如下，当测量到第一个RTT样本时，RTTD的值取为该样本值的一半，以后每测量到一个RTT样本时，都按该公式来计算新的RTTD的值。在上式中贝塔的取值大于等于0且小于1，已成为建议标准的RFC6298推荐的贝塔值为1/4，即0.25。我们可以发现不管是RTTS还是RTTD都是基于所测量到的RTT样本进行计算的。如果所测量到的RTT样本不正确，那么所计算出的RTTS和RTTD自然就要不正确，进而所计算出的超时重穿时间RTO也就不正确。

　　![](https://image.peterjxl.com/blog/image-20211219111436-62158ib.png)

　　‍

　　‍

　　然而往返时间RTT的测量确实是比较复杂的。我们来举例说明，主机A给主机B发送TCP数据报文段，但该报文段在传输过程中丢失了，当超时重传计时器超时后，主机A就重传该报文段，主机B收到后给主机A发送确认报文段。现在问题来了，主机A收到该确认报文段后，无法判断该报文段是对原报文段的确认，还是对重传报文段的确认。该报文段实际上是对重传报文段的确认，也就是说正确的RTT应该是这一段时间。但是如果主机A误将该确认当做是对原报文段的确认，也就是误认为这段时间是RTT则所计算出的RTTS和RTO就会偏大，降低了传输效率。

　　再来看另一种情况，主机A给主机B发送TCP数据报文段，主机B收到后给主机A发送确认报文段，由于某种原因，该确认报文段没有在正常时间内到达主机A这必然会导致主机A对之前所发送的数据报文段的超时重传。现在问题又来了，主机A收到迟到的确认报文段后，无法判断该报文段是对原报文段的确认，还是对重传报文段的确认。该报文段实际上是对原报文段的确认，也就是说正确的RTT应该是这一段时间。但是如果主机A误将该确认当做是对重传报文段的确认，也就是误认为这段时间是RTT，则所计算出的RTTS和RTO就会偏小，这会导致报文段没有必要的重传，增大网络负荷。

　　‍

　　![](https://image.peterjxl.com/blog/image-20211219113842-61k8rzs.png)

　　‍

　　‍

　　通过这两个例子可以看出，当发送方出现超时重传后，收到确认报文段时，是无法判断出该确认到底是对原报文段的确认，还是对重传报文段的确认，也就是无法准确测量出RTT，进而无法正确计算超时重传时间RTO。因此针对出现超时重传时，无法测准往返时间RTT的问题，Karn提出了一个算法，在计算加权平均往返时间RTTS时，只要报文段重传了，就要不采用其往返时间RTT样本，也就是出现重传时，不重新计算RTTS，进而超时重传时间RTO也不会重新计算。然而这要引起了新的问题，设想出现这样的情况，报文段的时延突然增大了很多，并且之后很长一段时间内都会保持这种时延，因此在原来得出的重传时间内，不会收到确认报文段，于是就重传报文段。根据Karn算法，不考虑重传的报文段的往返时间样本，这样超时重传时间就要无法更新，这会导致报文段反复被重传。因此要对Karn算法进行修正，方法是报文段每重传一次，就把超时重传时间RTO增大一些，典型的做法是将新RTO的值取为旧RTO值的两倍。

　　‍

　　接下来我们举例说明，TCP超时重传时间的计算，这是测量得到的第一个RTT样本RTT1。根据RTTS1的计算公式可知RTTS1的值.根据RTTDE的计算公式，可知RTTD1的值在根据IPO的计算公式可计算出RTO1的值，这是测量得到的第二个RTT2，根据RTTS2的计算公式和阿尔法的值和写出计算RTTS2的表达式，将之前计算出的RTTS1的值和本次测量得到的RTT2的值代入干涉，可计算出RTTS2的值。根据RTTD的计算公式和贝塔的值，可写出计算RTTD2的表达式，将之前计算出的RTTD1，RTTS,1以及本次测量得到的RTT2的值，代入该式，可计算出RTTD2的值。再根据RTO的计算公式，可计算出RTO2的值。假设这是测量得到的第3个和第4个RTT样本。计算一下RTO3和RTO4的值分别是多少？答案如图所示，相信大家都能正确解答。假设这是测量得到的第5个RTT样本，但是根据RTO4的值可知，在收到确认之前就会产生超时重传。我们之前介绍过，若出现超时重传，则不采用上述公式计算RTO，而是将新RTO的值取为旧RTO值的两倍。因此RTO5的值取为两倍的RTO4的值。

　　![](https://image.peterjxl.com/blog/image-20211219114149-oeud92l.png)

　　‍

　　本节课的内容小结如下

　　![](https://image.peterjxl.com/blog/image-20211219114201-pxld1wc.png)
