---
title: 实验17 开放最短路径优先OSPF
date: 2022-10-24 18:01:52
permalink: /Network/lab17-OSPF/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
---
# 实验17 开放最短路径优先OSPF

　　下面我们来进行一个仿真实验，本仿真实验的目的在于验证OSPF协议的作用，我已经在软件中构建好了这样一个网络拓扑，并且在每个设备的旁边都标注了所需要配置的IP地址，为了简单起见，本实验所采用的IP地址为主类IP地址，也就是采用默认子网掩码的分类IP地址，如果您还不会构建这样的网络拓扑，请您参照上次课的仿真实验，也就是有关RIP协议的仿真实验。

　　下面请您思考这样一个问题，  
如果这三台路由器运行的都是RIP协议，那么这台主机和上面这台主机，他们之间通信的数据包应该走哪一条路由？  
如果这三个路由器运行的是OSPF协议，那么同样的下面主机和上面主机，它们之间通信的数据包是否会和RIP一样走相同的路由？还是说与RIP不同走另外一条路由？

　　![image.png](https://image.peterjxl.com/blog/image-20220104202615-imepkdw.png)

　　根据我们上一次课有关RIP协议的介绍以及仿真实验，我们知道RIP协议他会选择低速链路这样一条路由，因为相对这样一条路由来说的话，那么只过两个路由器比过三个路由器距离更短，我们这儿的距离是指的路由器的数量，尽管这样的一条路由上面有一段低速的链路，但RIP协议认为这样的一条路由仍然是好的路由，因为RIP协议他只关心距离，也就是从源网络到达目的网络中间的路由器的数量

　　如果是OSPF协议，则会认为这样一条路由才是好的路由。因为OSPF协议它是基于链路状态的，所谓这种状态就是路由器它与邻居路由器之间的代价是多少，那么 邻居离路由器是否可达？那么对于思科的路由器，它计算这个代价是通过用100兆的带宽去除以链路本身的带宽，像我们这里面这两个路由器之间的这段电路，它是1G的带宽，这两个路由器之间它也是1G的带宽，那么我们用100兆去除以这段电路的1G，那么得到的是0.1，但是我们把它记作为一。同理，那么这一段的代价也是一，所以从网络要到达网络，那么走这样一条路由，它的开销就是二。

　　而如果要走这样一条低速路由，这个地方是一条低速的链路，如果你用100兆的带宽去除，以它的这一段低速电路的带宽的话，你得到的代价是远远大于我们刚才说的这样的一条路由的代价为二的，这个数值会非常大。

　　因此 OSPF它路由选择协议一定会使得从网络要到达网络的数据包会从路由器拿到路由器，再到这个路由器。接下来我们来看一下OSPF协议他是不是会选择这样一条路由。

---

　　‍

　　我们首先需要给各个主机配置IP地址，并指定默认网关，然后给这三个路由器各个接口配置IP地址，最后使能他们的OSPF协议。对于主机上面的IP地址的配置，它是取决于主机所运行的操作系统，例如WINDOWS系统、LINUX系统或者是苹果的MAC OS操作系统，那么它没有一个统一的这样的界面或者是统一的命令，因此在我们仿真软件里面，我们就通过仿真软件的界面对它配置就可以了。比方说点击上面这个主机，然后选择选项卡、里面的桌面，然后这儿有一个IP配置，然后把我们标注在旁边的这些IP地址信息给它相应的填进来，给它配置好就可以了。例如比如说我们给主机分配的IP地址是192.168.0.1，那么我们在这儿就给它设置为相应的192.168.0.1，然后我们这儿的子网掩码就填 C类的默认子网掩码就可以了。

　　然后再把默认网关的接口的IP地址192.168.0.254，那么给它输入进来就可以了。再给这两台主机配置完IP地址和默认网关以后，我们需要给这三台路由器的各个接口也配置相应的IP地址，那以及地址掩码。在我们以前的仿真实验当中，为了简单起见，我们对路由器的各接口的IP地址都是通过这样的一个界面的方式，比方说在这儿这个就是路由器的接口0，那么我们先把接口状态打开，然后输入IP地址，然后是子网掩码，在实践当中也就是实际工作当中实际上是不存在这样一个界面的，我们需要切换到命令行的方式来对它进行配置

　　那么下面我们就来演示一下如何通过命令行的方式给路由器的各个接口配置IP地址和子网掩码。首先我们为了区分路由器不同的接口，我们在菜单栏的这儿的选项，然后选择参数，然后在这把在逻辑工作空间中总显示端口标签这一项给它选中，这样的话我们就可以看到路由器的每个接口都会有一个接口号，比如说这个接口的话，它是串口0-0-0，这个是千兆的以太网口0/1，这个是千兆的以太网口0/0，只不过设备自动显示出来的端口标签会挡住我们标注在旁边的这些IP地址，那么我们稍微调整一下就可以了。那么右边这个路由器的话，那么它的这两个端口由于靠的比较近，所以它自动显示出来的端口号有重叠，我们仍然区分不了是哪一个，所以我们可以拖动一下。现在我们大致就可以看出来，那么这个口是0号口，这个口是一号口。我们再把它拖放回来。那么上面路由器的端口容易区分这个口是串口0，这个口是千兆的以太网的一号口，这个上面是千兆的以太网的0号口，那么他把 IP地址阻挡了，我们把它拖下来。

　　我们以上面这台路由器为例，来介绍一下如何通过使用命令给路由器的各个接口配置IP地址和地址掩码。我们点击这台路由器，然后选项卡选择命令行界面，这就是路由器的命令行配置界面，那么我们把这个窗口把它置顶，这样我点击到仿真软件的其他地方，这个界面它始终不会消失，它会显示在界面的最前方。

　　现在命令行问我们说是否要进行初始化配置，那么我们输入一个NO，回车，这样的话他提出我们按回车键就可以进行配置了，我们按回车键。那么在这样的一个命令提示符下面，我们输入enable进入到特权模式，然后我们再输入CONFIG 然后回车这样我们就要进入到了全局的配置模式，

　　那么我们先来配置路由器上面的接口，那么具体的命令是interface 端口的全名叫做 gigabit 吉比特，然后ethernet以太网，然后他的号码是0/0，所以我们输入0/0，  
这样我们就进入到了接口的配置模式。那么同理这个地方它显示的也是进入到了接口的配置模式，这个地方的IF实际上是 interface的缩写代表接口，而不是程序员比较熟悉的条件语句。  
然后我们就给它配置IP地址和地址掩码，具体的命令是IP address 192.168.0.254， 输入子网掩码或者叫地址掩码，那么具体的它是一个C类的，IP地址192就可以看出来，那么我们就用一个C类的默认的子网掩码，255.255.255.0，然后我们回车，那么这样接口的IP地址我们就要配置完了，我们还要把接口的状态给它变成打开，所以再输入一个命令叫做NO SHUTDOWN，这样的话这个端口就被开起来了，我们可以看到它的指示灯就变成了绿色的，

　　接下来我们配置一下接口，然后我们回车，那么我们首先要切换到接口的配置模式，所以我们这儿输入 interface，那么我们其实刚才配置接口的时候，我们用的是完整的命令，现在我可以用一个再演示一下，其实可以用简单的命令，我们不需要把命令打全，那么我们先切换到接口，那interface我们就输入一个int就可以了，然后它后面本身要跟着这一长串，我们就输入一个G就可以了，具体的端口号码是0/1，所以我们这儿写0/1，然后回车，这样我们就已经切换到了接口的它的配置模式，  
int g0/1

　　我们输入 IP  ADD 20.0.0.1， 然后空格输入它的地址掩码，这是一个A类的，从20就可以看出来是一个A类的这个IP地址，所以我们给一个A类的默认的子网掩码，然后255.0.0.0，然后回车，  
ip add 20.0.0.1 255.0.0.0  
不要忘记了，还要把这个接口给它状态给变成开启，也就是NO SHUTEOWNO

　　跟这个接口不同，我们把它的打开以后它仍然是红色，这是因为路由器的接口还没有开启。

```js
Router>enable
Router#config
Configuring from terminal, memory, or network [terminal]? 
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#interface gigabitethernet0/0
Router(config-if)#ip address 20.0.0.1 255.0.0.0
Router(config-if)#no shutdown
```

　　接下来我们再配置一下路由器的串行的接口，仍然我们要切换过去ING ，它的名称我们把它简写为S0/0/0， 然后回车，接下来就给他配置IP地址，IP Add 就可以了，然后它的IP地址我们规划的是30.0.1，那相应的子网掩码的是一个255三个0。  
同样的我们要把它的状态给它开启， NO shutdown。好总理他的状态指示灯也没有变成绿色，因为路由器的接口还没有开启。

　　这样一来我们来看一下，我们原来以前仿真实验里面的简单，我们是通过在仿真软件的提供的配置界面，比如说点配置，然后这是接口0，我们原来是在这儿选打开，然后把IP地址输入进来，子网掩码输入进来，现在我们是通过了命令行的方式来实现的。实践当中就是应该通过命令行的方式，而不可能会出现有界面的方式给你来配置。那么请您将这一台路由器，还有这一台路由器的各个接口的 IP地址，通过命令行的方式，以命令的方式给他们配置我这里就要不再演示了。

　　‍

　　‍

---

　　再给路由器的各个接口配置好IP地址以后，路由器就可以得出它各个接口所直连的网络。那么在以前的仿真实验中，我们都是通过这边的查看按钮，然后点击路由器，然后选择路由表来查看路由器里面的路由条目。那么其实也可以通过命令行的方式来查看路由器的路由表，那么我们这里也演示一下。

　　首先把鼠标状态切换回选择状态，然后我们选择这台路由器，在他的命令行界面，首先这是我们刚才配置了各个接口，所以现在在某一个接口的配置模式下，那么我们应该模式 退出，输入EXIT  
那么退出后进入到这是全局配置模式，那么我们还需要退出，输入EXIT那么这样的话回车就到了特权模式。

　　那么具体的显示路由器路由表的命令是受SHOW IP ROUTE 。这样的话我们就可以看到以命令行的方式，我们也可以看到这个地方列出了路由器的路由条目，那和我们在界面上看到的呢是一样的。需要说明的是实践当中是不会有查看按钮来以这种界面的方式给大家看的，实践当中都是通过命令行的这种方式，通过命令在命令行把它显示出来

```js
Router#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     20.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C       20.0.0.0/8 is directly connected, GigabitEthernet0/0
L       20.0.0.1/32 is directly connected, GigabitEthernet0/0
     30.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C       30.0.0.0/8 is directly connected, Serial0/0/0
L       30.0.0.1/32 is directly connected, Serial0/0/0
     192.168.0.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.0.0/24 is directly connected, GigabitEthernet0/1
L       192.168.0.254/32 is directly connected, GigabitEthernet0/1
```

　　那么这两台主机现在是否可以正常的通信？答案是不能，因为现在这三台路由器他们仅知道各自直连的网络，那么我们最开始介绍的是手工给他添加静态路由的方法，也就是把网络添加给路由器，告诉他有这样一个网络存在。下一跳需要跳给路由器这个路由器也就把路由器的接口告诉路由器。那么后来我们又学习了RIP协议，那么也就是使能各个路由器的RIP协议，或者叫做启动各个路由器接各接口的RIP协议，这样让RAP协议自动获取到达各个网络的最好的这样的一条路由。

　　‍

---

　　我们这一次的实验是为了验证OSPF这个协议，所以我们相应的应该把各个路由器的各个接口，它的OSPF这个协议给给它启动起来。下面我们以这台路由器为例，来介绍一下如何使能它各个接口的OSPF协议，那么我们点击左边这台路由器，然后到命令行界面，我们回车，然后首先输入en，这是enable的简写，我们进入到了特权模式，然后输入CONF这是CONFIG的简写，然后空格T那么我们可以进入到配置模式，然后我们输入一个router OSPF然后空格再输入一个数值，这个是进程号。那么我们假如说输入100，那么你可以随意一般1~6535的都可以，然后回车，这样我们就要进入到了 OSPF协议的配置界面。

　　那么下面我们就要逐个来启动它各个接口的 OSPF协议，具体的命令是NETWORK 实际上就是通道它各个接口所连接的网络。那么比如说它的串口0是30.0.0.0网络，所以我们这就30.0.0.0，

　　然以后应该输入的是反地址掩码跟我们以前使能RIP的时候输入地址掩码是不一样的，这个地方输入的是反地址掩码，什么意思？这是一个A类网络，它的地址掩码默认的词宝掩码应该是一个255三个0，现在相当于把他的每个位置都给它取反，也就是32比特，如果给它化成32比特的话，那么它的地址掩码应该是1个255，也就是8个二进制比特的一，剩下的就是24比特的0，那么现在把它反过来应该就是8个比特的0，剩下24个比特的0的全部变成一，所以地址反掩码应该是0.25 5.  
255.255。好这个地方要特别注意，不要输入错了，这个地方是反地址掩码，也就是原来是按255.0.0.0，现在就应该变成0.255.255.255。那么有一个简单的方法，就是你用4个255对应的去把它正常的地址掩码的对应的位置上去做相减，那么得到的就是一个反的这样的一个地址掩码。然后再空格输入一个AREA，这是区域的意思。

　　那么我们这里面演示的是 OSPF它这几个路由器呢是属于同一个OSPF区域的，我们在理论课中曾经讲过， OSPF它可以划分区域，分为主干区域和一般区域，这样它可以限制链路状态更新的分组就在本区域内进行。那么这里面我们就演示一个单区域的假设，它就是主区域，这三个路由器都是同一个主区域，主干区域，所以我们这儿是区域空格0，让它属于区域0。

```js
Router>en
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#router ospf 100
Router(config-router)#network 30.0.0.0 0.255.255.255 area 0
Router(config-router)#
```

　　那么这样我们就把接口所在网络这样通告一下，相当于使得路由器的接口的OSPF协议，

　　那么我们在使能下一个比如说这个地方NETWORK然后空格10.0.0.0，网络这个接口连的是网络，那么同样的地址掩码是它的正常的掩码的，反过来也就是0.255.255.255，然后区域是AREA 0，

　　那么下面我们再来使它下面这个接口， NETWORK 192.168.1.0，那么它的地址掩码正常的话应该是三个，这是C类的，所以应该是三个255一个0，那么反掩码就应该是0.0.0.255，那么区域还是区域area然后空格0回车，那么这样的话我们就把路由器的各个接口的OSPF的协议给它启动了。

```js
Router(config-router)#network 10.0.0.0    0.255.255.255   area 0
Router(config-router)#network 192.168.1.0   0.0.0.255    area 0
```

　　那么请您把路由器还有路由器的OSPF的协议都给它启动了，我这里就要不再做具体的演示了，

　　再给各个路由器使能了OSPF协议以后，那么它们之间就要交互周期性的交互HELLO分组以建立邻居关系之后，他们会通过数据库描述分组，链路状态请求分组，链路状态更新分组以及链路状态更新确认分组这样一系列的分组进行交互，最终使得他们各自的链路状态数据库达到一致，也就是我们说他们达到了同步状态，这样他们在根据链路状态数据库得出一个带权的有向图，然后每个路由器基于这个带权的有向图，来构建自己的最短路径，到达其他路路由器的最短路径，进而形成各自的路由表。

　　‍

　　‍

---

　　我们现在就来查看一下，我们还是用简单方法，用这儿的查看按钮来查看路由器的路由表。那么我们调整一下，那么路由器的路由表，我们凡是标C和标L的，我们前面介绍过了，是直连的这种网络和自己的接口的IP地址，我们不去看它，那么我们就看一下标了O的这个类型标的O实际上路由条目就是OSPF协议得出来的。那么我们先来看这一条，也就是路由器，它现在通过OSPF协议学习到了一个网络，10.0.0.0在图上就是网络，那么他要到网络来的话，我们可以看到下一跳，他要跳到20.0.0.2，也就是要跳给路由器的接口，那么这个地方度量写的是110/20，那么我们解释一下前面110是 OSPF的管理距离，也就是它的可信程度，如果有同样一条路由信息是通过RIP特来的话，它的这个地方应该写120，那么这个时候其实我们会选择哪一个路由？当然是选择OSPF的这一条，因为我们认为它更可信，斜线后面这个数字是计算出来的代价。我们来看一下它为什么计算出来的是二，因为从路由器要到达10.0.0.0网络，那么有这一段电路，还有这一段电路，这两段电路都是1G的带宽，那么思科路由器它是用100兆去除以这段的电路带宽，那么得出来0.1，1以下的，他都认为是一，同理这一块也是100兆除以1G那算出来的是0.1，他也认为是一，所以这个代价加起来就是二，所以这里写的是二。

　　那么这一条路由就是说我路由器要到网络去要下一跳跳给路由器，那么整个的代价是二。

　　![image.png](https://image.peterjxl.com/blog/image-20220104205713-rbl8vpf.png)

　　‍

　　我们再来看一下，这一条的话它是到达目的网络192.168.1.0，也就是到达网络，路由器到达网络它下一跳，很显然这个地方告诉我们跳的是20.0.0.2，也是跳这个路由器，那么距离这个地方的三是怎么得出来的？也就是这儿的代价是一，这的代价是一，而这个地方接口是1000兆的口是100兆的，所以就按100兆的算，这个链路是按100兆的算，所以它的代价是用100兆的带宽除以它本身的100兆带宽，所以是一，那这样的话整个的代价1+1+1就是三。

　　‍

　　‍

　　‍

---

　　‍

　　那么我们再来看一下右边的路由器它的路由表，那么它的路由表的内容我们来看一下比较多，有4个通过OSPF得出的。那么我们一条一条来看，这个地方30.0.0.0也就是路由器到达网络，他下一跳，他告诉我们可以跳20.0.0.1也就跳这个接口，就到达了网络，具体的度量也就是代价这个地方是65。那么我们刚才已经说过这一段链路它是一，那么它现在算出来整个代价65，我们就可以知道这一段其实它算出来是64，因为这是一个串行链路，它的带宽非常小，你用100兆去除以它计算出来实际上是64，所以这样这两段加起来是65。

　　我们再看一下，他还得出来到达网络还有一条路由，这两条路由是到达同一个目的网络的，那么这条路由它让我们走的是下面这一条，也就是说他下一跳，给的是10.0.0.1，也就是给这个地方，那么它的代价仍然是65，也就是这一段的代价是一，这一段的代价是64，那么这两条都是到达同一个目的网络，只不过下一跳不同，但是他们的代价都相同，所以这两个路由是等价的，所以他应该是在这上面做负载均衡。

　　那么我们再看一下这一条，到192.168.0.0，那么也就是到达网络路由器，到达网络，他告诉我们说下一跳应该跳到20.0.0.1，也就是跳到这里面去，跳到路由器的接口，那么到达最终网络的这个代价是二，因为这个地方计算出来代价是一，而这个地方计算出来也是一。

　　那么最后这一条是说到下面网络192.168.1.0，这个路由器它下一跳，应该跳给这个接口，也就是10.0.0.1，这告诉我们跳到这儿，那代价也是二，因为一这儿的代价是一。

　　当然我们可以看到还有一条路，比如说要到网络去，它可以走上面这儿，再走下面这儿再走下面，但是这一条路的话，这儿的代价是一，这儿的代价64，这儿的那代价的是一，加起来是66，比这一条路比从这儿走过来的代价是二要大很多，所以OSPF的最短路径，他当然会选择代价最小的这一条路由。

　　![image.png](https://image.peterjxl.com/blog/image-20220104205916-89j7679.png)

　　‍

　　‍

　　‍

　　‍

　　下面我们就来检验一下，看看这台主机是否可以和这台主机正常通信了。那么我们先把鼠标状态切回到选择状态，然后我们点击这台主机，然后到它的桌面选项卡，然后到它的命令提示符。那么在这里面我们来Ping一下，我们用这台主机来Ping一下这台主机。 PING 192.168.0.1，然后停车，按理来说应该是可以Ping得通的，因为各个路由器已经找好了这些到达各个目的网络的路由，只不过我们这里边看到它总共会连续的Ping4次，那么第一次Ping的时候也就是超时了。那么我们之前就讲过，那么它里面存在一个ARP地址解析的这样的一个问题，所以有一次丢包的情况，有的时候你在做其他实验的时候可能还会丢的包的数量更多，都是因为 ARP的请求造成的。那之后我们就可以看到收到了三次192.168.0.1主机发回来的响应，那么我们再Ping一次，那应该是发了4个请求，那么相应的收到4次这样的一个响应，这就代表这2台主机可以相互通信。

```js
C:\>ping 192.168.0.1

Pinging 192.168.0.1 with 32 bytes of data:

Request timed out.
Reply from 192.168.0.1: bytes=32 time=1ms TTL=125
Reply from 192.168.0.1: bytes=32 time<1ms TTL=125
Reply from 192.168.0.1: bytes=32 time<1ms TTL=125

Ping statistics for 192.168.0.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 1ms, Average = 0ms
```

　　‍

　　‍

　　那么现在我们还想看一下，就是说这两台主机通信的数据包，它到底是走的这条低速电路的，还是走的这边的高速电路？那么我们前面说过了对RIP协议它一定会走这个低速的，为什么？因为这两个主机的话走低速电路的话，中间就间隔这两个路由器，也就是距离为二。但是对于OSPF协议的话，它是以这个代价作为度量的，我们计算的电路的代价一一这是64，所以如果是OSPF的话，它应该是一这一段代价加这一段代价，再加这一段代价，比起这段代价加这一段代价再加这一段代价要小很多，所以它一定是这样一条路径这样一个路由。那么我们来验证一下，看看是不是，那么我们先从实时模式切换到仿真模式，然后这个里面我们不需要让他帮我们监听那么多的协议，我们把他们全部隐藏掉，然后我们只要看一下 ICMP就可以了，因为我们现在要用ICMP协议打一个数据包，那么就选择这个地方添加简单的PDU那么它其实就是用 ICMP协议打的包，我们点击它，然后指定源主机，然后再指定目标主机。这样的话我们点击这个地方的捕获前进，我们看到主机先把数据包发给他的默认网关，然后这个时候他要么从上面转发走，要么从右边转发走，那么现在我们用的是OSPF协议，所以他应该是查他的路由表，他的路由表里面那条路由记录一定会把它指向到路由器，我们看一下是不是，确实是这样的，然后路由器再转发到上面的路由器，那么最终路由器转发给目的主机，目的主机收到以后会给源主机发回一个ICMP的响应，那么我们再点击下一步，然后到了路由器，那么它应该又是从下面转发右侧这个地方转转下来，然后再转给左边路由器，最后再转发给最初的源主机。

　　![image.png](https://image.peterjxl.com/blog/image-20220104210509-5qjvlui.png)

　　‍

　　‍

　　‍

　　这样我们就要验证了 OSPF他选择的路由是依据这个代价以走的代价最小来作为好的路由。本次实验就到这里结束了，相信您已经深刻体会到 OSPF协议的作用，以及如何起到路由器的 OSPF的协议

　　‍

　　‍

　　‍

　　‍

　　‍
