---
title: 实验2 MAC地址，IP地址，ARP协议
date: 2022-10-03 18:01:52
permalink: /Network/lab2-address-arp/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
feed:
  enable: true
description: 本仿真实验的内容是验证MAC地址与IP地址的关系，以及ARP协议的作用。
---

# 20.实验2：MAC地址，IP地址，ARP协议

本仿真实验的内容是验证 MAC 地址与 IP 地址的关系，以及 ARP 协议的作用。

<!-- more -->


我们首先拖动两台计算机到逻辑工作空间，然后选择自动连线，让他们互联起来，作为左边这台计算机配置 IP 地址 192.168.0.1，给右边这台计算机配置 IP 地址 192.168.0.2，我们可以在右边的工具栏点击查看，来查看计算机的端口状态汇总表以及 ARP 表：

​![](https://image.peterjxl.com/blog/image-20211226200954-kfj9by0.png)​

我们看一下端口状态汇总表，这是计算机的以太网卡，这是我们刚才配置的 IP 地址，这是网卡上面的 MAC 地址：

​![](https://image.peterjxl.com/blog/image-20211226201103-a41e5yl.png)​

我们还可以再查看一下它的 ARP 高速缓存表，目前来说它是空的：

​![](https://image.peterjxl.com/blog/image-20211226201313-qnnascz.png)​

我们把鼠标状态切换回选择状态，然后切换实施模式到仿真模式，我们现在让左边的计算机给右边的计算机发送一个简单的数据包：

就点右边的信封上的一个加号，让左边的计算机给右边的计算机发送：

我们可以看到这个数据包本身是用 ICMP 协议构建的，但是在体系结构的第二层准备封装成帧的时候，发现目标 IP 地址并不在自己的 IP 缓存中，所以没有办法找到相应的 MAC 地址，所以暂时不能发送 ICMP 的数据包，只能发送一个 ARP 的请求，于是就构建一个 ARP 的请求帧。

​![](https://image.peterjxl.com/blog/image-20211226201409-zwc4ypg.png)​

我们可以看到 ARP 的请求跟它的目的 MAC 地址填为全 F 也就是广播地址。我们看一下它的具体的封装细节，就是 ARP 协议构建的数据包，那么这是它的原 MAC 地址和 IP 地址，也就自己的，下面的是他要发送数据包的目的地址，但是他不知道这个目的地址对应的 MAC 地址。ARP 协议打完包以后要封装成以太网的帧就放在这个位置上。那么注意一下目的地址，填的是全 F，也就是一个广播地址：

​![](https://image.peterjxl.com/blog/image-20211226201520-dxyvz8q.png)​

我们点击下一步，那么我们可以看到 ARP 广播请求到达了右边这台计算机，我们点开看一下细节，右边这台计算机把它解析以后发现这是一个 ARP 的广播请求，他先把 ARP 的里面带来的信息更新到自己的 ARP 的高速缓存表里，这个信息就是左边发 IP 广播请求的主机它的 IP 地址以及 MAC 地址的对应关系：

​![](https://image.peterjxl.com/blog/image-20211226201615-pyh4ped.png)​

现在右边这台主机知道了，对方是来询问自己的 MAC 地址的，所以它就要构建一个 ARP 的单播的这样的一个响应。

那目的地址它是要发给左边这台计算机的，所以就填左边这台计算机的 MAC 地址。那么这个就是右边这台计算机构建的用 ARP 协议构建的单播的响应，那么里面的原 MAC 地址和原 IP，地址放的是自己的，目的 MAC 地址和目的，这个 IP 地址放的是对方的，

我们现在就可以再点下一步来看一下，那么这个 ARPP 的单播响应就发送回去了。那么给大家看一下左边这台计算机收到单播响应以后进行解析，发现了这是一个 ARP 的响应，于是他把 ARP 的包里面的信息取出来，来更新它自己的 ARP 缓存表，然后他再把 ICMP 的数据报就刚才没有发的数据报包也发出去了。我们现在来查看一下它更新完了自己的 ARP 高速缓存表这样的一个内容。这个内容就是他已经知道了，对方的 IP 地址和 MAC 地址都有关系：

​![](https://image.peterjxl.com/blog/image-20211226201637-lznevru.png)​

再前进，这就是我们本来想发的 ICMP 的数据包终于被发出来了，那么收到后再给对方发回一个 ICMP 的响应：

​![](https://image.peterjxl.com/blog/image-20211226201926-q06d3g0.png)​

那么我们再次来看一下，让左边再给右边发一个 ICMP 的数据包，这个时候我们就可以看到是直接发送 ICMP 数据包了，而不会再像最初一样要有一个 ARP 的广播请求去询问 IP 地址和 MAC 地址的对应关系：

​![](https://image.peterjxl.com/blog/image-20211226202126-cbrptpy.png)​

下面我们可以通过命令来把左边的 ARP 的高速缓存表给它清了，我们先用 ARP  -a 先看一下它里面进入了右边这台计算机的 IP 地址和 MAC 地址的对应关系，我们输入 ARP -d 我们再输入 ARP -a 来查看一下，那么这说明的内容已经被我们删除了，我们再次用 ICMP 的来发包，我们会发现它又再次调用了 ARP 的广播请求：

​![](https://image.peterjxl.com/blog/image-20211226202228-tt1ewmv.png)​

​![](https://image.peterjxl.com/blog/image-20211226202219-mwzior3.png)​
