---
title: 实验14 聚合了不存在的网络导致的路由环路问题
date: 2022-10-24 18:01:52
permalink: /Network/lab14-Routing-Loops-2/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
---
# 实验14 聚合了不存在的网络导致的路由环路问题

　　‍下面‍‍我们来进行一个仿真实验，本仿真实验的目的在于验证，由于聚合了不存在的网络，‍‍而导致静态路由的路由环路问题，‍‍我已经在软件中构建好了我们理论课程中所用到的网络拓扑，‍‍并且给网络中的每个设备都配置了相应的IP地址和地址掩码。‍‍对于网络中的各个主机，我还给他们指定了默认网关，‍‍例如主机H1它的默认网关是路由器R1，‍‍相应的是路由器R1的接口，这是它的IP地址。‍‍

　　另外‍‍我还给图中的每个路由器配置了一条静态路由，‍‍例如R1的静态路由是一条默认路由，‍‍那也就是0.0.0.0，它的相应地址掩码是0，‍‍而下一跳，我让他跳给路由器R2具体是路由器R2的接口，也就是这个IP地址。‍‍那对于路由器R2呢，‍‍我给它添加了一条静态的聚合路由，也就是把主机H1所在的网络和主机H3所在的网络‍‍把它们聚合成一个更大的网络。那么也就是192.168.0.0/22，‍‍相应的我们要让R2它的下一跳为R1，也就是R1的接口，也就是这个IP地址，‍‍也就是10.0.1，

　　![image.png](https://image.peterjxl.com/blog/image-20220103152830-ezzzybd.png)

```js
/22的计算过程
1111 1111       1111 1111        1111 1100         0000 0000
255.255.252.0
```

　　‍

---

　　下面我们就来验证一下‍‍网络中的各个主机是否可以相互通信，以检查我们IP地址配置的是否正确，‍‍以及静态路由设置的是否正确。‍‍我们用主机H2来Ping一下主机H1点击主机，H2选择桌面-选择命令行。Ping一下主机H1的IP地址是‍‍192.168.1.1，‍‍第一条请求超时了，‍‍第二条请求也超时了，第三条收到了来自192.168.1.1的响应，也就是主机H1给H‍‍2发回的响应。第4条也收到了。那么我们再Ping一下，‍‍现在就可以连续的收到了，之前的超时是由于中间有ARP的过程，‍‍

```js
C:\>ping 192.168.1.1

Pinging 192.168.1.1 with 32 bytes of data:

Request timed out.
Request timed out.
Reply from 192.168.1.1: bytes=32 time<1ms TTL=126
Reply from 192.168.1.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.1.1:
    Packets: Sent = 4, Received = 2, Lost = 2 (50% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　‍

　　我们下面再来拿主机H2去Ping 主机H3， Ping ‍‍192.168.2.1回车。‍‍第一条请求超时，‍‍第2条、第3条、第4条都是顺利的收到了H3给H2发回来的响应。‍‍

```js
C:\>ping 192.168.2.1

Pinging 192.168.2.1 with 32 bytes of data:

Request timed out.
Reply from 192.168.2.1: bytes=32 time=5ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.2.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 5ms, Average = 1ms
```

---

　　下面我们来详细看一下路由器R2当中的这条聚合路由，‍‍它的目的网络192.168.0.0/22，聚合了以下4个网络，‍‍第一个网络是192.168.0.0/24，‍‍这个网络在我们的网络拓扑中并不存在。‍‍第二个网络是192.168.1.0/24，‍‍这个网络其实在我们网络拓扑中就是主机H1所在的网络。‍‍第三个网络是192.168.2.0/24，‍‍这个网络在我们网络拓扑中就是主机H3所在的网络。‍‍第4个网络是192.168.3.0/24，‍‍这个网络在我们的网络拓扑中也不存在，

　　‍

　　‍

　　‍

---

　　现在请您思考一下这样一个问题，‍‍如果主机H2中的某个应用进程，‍‍想给网络中的某个主机发送一个IP数据报，那么由于网络是不存在的，‍‍会出现什么样的情况？我们来进行一下仿真，从实时模式切换到仿真模式，‍‍然后我们隐藏掉这些需要监听的协议，只选一个ICMP协议就可以了。‍‍然后我们选择右侧的添加复杂的PDU然后点击主机H2。‍‍我们刚才说的让主机H2给192.168.3.0网络中的某台主机，那么目的IP地址我们‍‍例如就填为192.168.3.1，而源IP地址我们这可以不填，就是H2的主机。‍‍TTL生存时间我们这儿给小一点，我们给成8，然后序号我们给成一，单次仿真的时间也是一秒，创建PDU。下面我们就点击捕获前进按钮，‍‍我们可以看到 ICMP报文就发出来了，当然它是封装在IP数据报里面的，‍‍好我们把鼠标这个状态先切回选择状态，然后我们来看一下R2路由器对这个数据包的处理，‍‍那么这个是数据包进入路由器，以后层层解封装。‍‍我们可以看一下它进入路由器的时候，它的生存时间是8，‍‍然后我们可以看到路由器准备对他进行转发，‍‍因为它是要到目的网络192.168.3.0的，而R2路由器里面的这条聚合路由就包含了网络，‍‍这条聚合路由的下一跳是10.0.0.1，也就是R1，所以 R2路由器会把这个IP数据包转发给R1。‍‍我们看一下这是他准备转发，然后又层层给它封装起来，‍‍最终封装成以太网的帧，我们看一下封装细节，我们主要关心的这里面的TTL我们发现‍‍当他要离开 R2路由器以后，它的生存时间被减了一，也就是每过一个路由器它会减一跳。

　　‍‍那么我们继续捕获，‍‍现在他进入了路由器R1，我们再来看一下又是层层解封，然后这边要把它转发出来。‍‍我们先看一下它入站的时候生存时间还是6，那么出站的时候封装的时候生存时间就是5了。‍‍那么我们再来看一下它到底是转发到哪里去？‍‍那么在我们 R1路由器里面的话， IP数据报它把它的目的地址取出来是192.168.3.1，‍‍那么在这个里面的话没有一条匹配记录，它只会走默认路由，‍‍而这个默认路由告诉我们的是下一跳跳到10.0.0.2，也就是R路由器的接口，‍‍所以 IP数据报会再从R1发回到R2。‍‍

　　![image.png](https://image.peterjxl.com/blog/image-20220103154507-qleqnru.png) 

　　![image.png](https://image.peterjxl.com/blog/image-20220103154519-13t01o2.png)

　　‍

　　同理了，这个IP数据报还会再次发给R1，‍‍ R1又会发给R2，就这样来回的反复在R1和R2之间转发，‍‍直到这个IP数据报的TTL值为0，那么我们再前进几步。‍‍现在我们可以看到R1在收到 IP数据报以后，‍‍层层解封以后，他发现数据包的 TT L值到期了，我们看一下‍‍他进来的时候是1，那么路由器再把它减一，准备转发的时候发现TTL值为0，所以这个时候‍‍就会把他丢弃了，‍‍丢弃以后我们可以看到这里还有一个红色的，那么这个是表示在我们这儿也写了，‍‍这个R1的路由器会向他丢弃的他所丢弃的‍‍这个IP数据报的发送方，发送 ICMP的时间超过的这样的一个通知报文。

　　![image.png](https://image.peterjxl.com/blog/image-20220103154601-ysqrmvq.png)

　　‍‍‍‍这样的话‍‍当通知报文到达主机H2以后，我们主机H2里面发送之前的 IP数据报的进程就可以知道，‍‍原来是他的所发送的 ID数据报在路由器R1‍‍的时候， R1把它给丢掉了。‍‍

　　‍

　　‍

　　‍

　　‍

---

　　‍

　　那么如何解决IP数据报在路由器R1和R2之间反复的转发。‍‍这种路由环路问题，我们应该在R1路由器的路由表中，针对‍‍192.168.3.0/24这个不存在的网络，针对它添加一条‍‍所谓的黑洞路由，也就是说到192.168.3.0/24，这个不存在的网络去的话，‍‍如果数据包要去到这儿的话，那么让路由器直接转发给他自己的null0接口，‍‍null0接口是一个虚拟的接口，‍‍你可以认为是IP数据报进到这个接口以后就不会再出来了，有去无回。‍‍那也相当于是R1就把这个IP数据报给它丢弃掉了。‍‍

　　我们现在就来给R1路由器添加这条黑洞路由，点击路由器，‍‍然后进入到命令行界面回车，‍‍然后我们输入以ENABLE然后我们输入CONFIG 再回车。‍‍下面我们就进入到了这种配置模式，然后我们给它设定一条黑洞路由命令是ip ROUTE‍‍ 路由，给定它的网络地址192.168.3.0，‍‍相应的地址掩码是‍‍通过24，我们就知道有24比特连续的一，剩下8比特连续的0写成点分10进制形式，‍‍255.255.255.0，‍‍然后空格再给一个NULL0。指名下一跳交到哪里，这个接口本身是不能配IP地址的。‍‍这个意思是说给R1添加一条路，由路由到目的网络是192.168.3.0，相应的地址掩码三个255一个0，‍‍而下一跳，应该跳到NULL0这个接口。‍‍我们回车，‍‍这样就要配置完成了

```js
Router>enable 
Router#config
Configuring from terminal, memory, or network [terminal]? 
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#ip route 192.168.3.0 255.255.255.0 null0
```

　　下面我们就再让主机H2给不存在的网络的某一台主机，‍‍再次发送一个ICMP的报文，当然它是封装在IP数据报中进行发送的，‍‍那么我们先把之前的这些实验场景给它删除掉，‍‍我们点击右下角的箭头，然后点击这儿的删除，这些场景就被删除掉了。‍‍

　　‍

　　‍

---

　　‍

　　下面我们再来发送一个复杂的PDU那点主机H2，‍‍然后目的IP地址就是这个不存在网络当中的，‍‍例如是192.168.3.1，‍‍源IP就是主机H2的我们不用填了， TTL直默认32就可以了，序号我们写一，单次仿真时间也写1。‍‍好创建PDU我们最好把鼠标状态再切回选择状态。‍‍下面我们就点捕获前进。‍‍

　　ICMP的报文被封装在IP数据报以后发送出来了，那么R2查找路由表，‍‍那么由于它 IP数据报是到192.168.3.1，也就是属于网络，‍‍而这个网络其实是聚合在了 R2路由器里面的这条聚合路由‍‍所指示的目的网络里面的，所以R2会把它按照下一跳10.0.0.1也就跳给R1，‍‍转发给R1，我们来看一下。‍‍

　　那么当这个IP数据报转发到R1以后， R1把它删除了

　　![image.png](https://image.peterjxl.com/blog/image-20220103173822-1liuir3.png)

　　‍

　　我们来看一下细节，‍‍这个IP数据报进来以后，从以太网的帧层层解封到‍‍网络层，网络层解封到这个程度以后，他准备去转发了，所以他就要构建转发的包。‍‍但是他转发的时候发现他的转发表里边有一条匹配的‍‍路由记录，也就是这条黑洞路由。‍‍而这条黑洞路由的下一跳，是一个null0接口，‍‍所以路由器R1就会把这个数据包给丢弃掉。‍‍这样的话呢就我们就会看到，‍‍被丢弃以后就不会在R1和R2之间 IP数据报反复被转发，‍‍这样就要不存在环路问题了

　　![image.png](https://image.peterjxl.com/blog/image-20220103173834-gyt4bxg.png)

　　实验就要进行到这里了。‍‍希望通过本实验，您对聚合了不存在的网络，而导致静态路由的路由环路问题有了更深刻的理解，‍‍并且已经学会了使用黑洞路由来解决这种问题的方法

　　‍
