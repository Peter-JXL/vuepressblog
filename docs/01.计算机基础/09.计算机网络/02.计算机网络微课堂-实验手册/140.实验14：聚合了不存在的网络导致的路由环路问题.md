---
title: 实验14 聚合了不存在的网络导致的路由环路问题
date: 2022-10-13 18:01:52
permalink: /Network/lab14-Routing-Loops-2/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
feed:
  enable: true
description: 下面‍‍我们来进行一个仿真实验，本仿真实验的目的在于验证，由于聚合了不存在的网络，‍‍而导致静态路由的路由环路问题
---


# 140.实验14：聚合了不存在的网络导致的路由环路问题

下面我们来进行一个仿真实验，本仿真实验的目的在于验证，由于聚合了不存在的网络，而导致静态路由的路由环路问题。

<!-- more -->


我已经在软件中构建好了我们理论课程中所用到的网络拓扑，并且给网络中的每个设备都配置了相应的 IP 地址和地址掩码。对于网络中的各个主机，我还给他们指定了默认网关，例如主机 H1 它的默认网关是路由器 R1，相应的是路由器 R1 的接口，这是它的 IP 地址。

另外我还给图中的每个路由器配置了一条静态路由，例如 R1 的静态路由是一条默认路由，那也就是 0.0.0.0，它的相应地址掩码是 0，而下一跳，我让他跳给路由器 R2 具体是路由器 R2 的接口，也就是这个 IP 地址。那对于路由器 R2 呢，我给它添加了一条静态的聚合路由，也就是把主机 H1 所在的网络和主机 H3 所在的网络把它们聚合成一个更大的网络。那么也就是 192.168.0.0/22，相应的我们要让 R2 它的下一跳为 R1，也就是 R1 的接口，也就是这个 IP 地址，也就是 10.0.1。

​![](https://image.peterjxl.com/blog/image-20220103152830-ezzzybd.png)​

```
/22的计算过程
1111 1111       1111 1111        1111 1100         0000 0000
255.255.252.0
```

‍

‍

---

下面我们就来验证一下网络中的各个主机是否可以相互通信，以检查我们 IP 地址配置的是否正确，以及静态路由设置的是否正确。我们用主机 H2 来 ping 一下主机 H1 点击主机，H2 选择桌面-选择命令行。ping 一下主机 H1 的 IP 地址是 192.168.1.1，第一条请求超时了，第二条请求也超时了，第三条收到了来自 192.168.1.1 的响应，也就是主机 H1 给 H2 发回的响应。第 4 条也收到了。那么我们再 ping 一下，现在就可以连续的收到了，之前的超时是由于中间有 ARP 的过程。

```
C:\>ping 192.168.1.1

Pinging 192.168.1.1 with 32 bytes of data:

Request timed out.
Request timed out.
Reply from 192.168.1.1: bytes=32 time<1ms TTL=126
Reply from 192.168.1.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.1.1:
    Packets: Sent = 4, Received = 2, Lost = 2 (50% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

我们下面再来拿主机 H2 去 ping 主机 H3：ping 192.168.2.1 。第一条请求超时，第 2 条、第 3 条、第 4 条都是顺利的收到了 H3 给 H2 发回来的响应。

```
C:\>ping 192.168.2.1

Pinging 192.168.2.1 with 32 bytes of data:

Request timed out.
Reply from 192.168.2.1: bytes=32 time=5ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.2.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 5ms, Average = 1ms
```

---

下面我们来详细看一下路由器 R2 当中的这条聚合路由，它的目的网络 192.168.0.0/22，聚合了以下 4 个网络，第一个网络是 192.168.0.0/24，这个网络在我们的网络拓扑中并不存在。第二个网络是 192.168.1.0/24，这个网络其实在我们网络拓扑中就是主机 H1 所在的网络。第三个网络是 192.168.2.0/24，这个网络在我们网络拓扑中就是主机 H3 所在的网络。第 4 个网络是 192.168.3.0/24，这个网络在我们的网络拓扑中也不存在。

---

现在请您思考一下这样一个问题，如果主机 H2 中的某个应用进程，想给网络中的某个主机发送一个 IP 数据报，那么由于网络是不存在的，会出现什么样的情况？

我们来进行一下仿真，从实时模式切换到仿真模式，然后我们隐藏掉这些需要监听的协议，只选一个 ICMP 协议就可以了。然后我们选择右侧的添加复杂的 PDU 然后点击主机 H2。我们刚才说的让主机 H2 给 192.168.3.0 网络中的某台主机，那么目的 IP 地址我们例如就填为 192.168.3.1，而源 IP 地址我们这可以不填，就是 H2 的主机。TTL 生存时间我们这儿给小一点，我们给成 8，然后序号我们给成 1，单次仿真的时间也是一秒，创建 PDU。

下面我们就点击捕获前进按钮，我们可以看到 ICMP 报文就发出来了，当然它是封装在 IP 数据报里面的，好我们把鼠标这个状态先切回选择状态，然后我们来看一下 R2 路由器对这个数据包的处理，那么这个是数据包进入路由器，以后层层解封装。我们可以看一下它进入路由器的时候，它的生存时间是 8，然后我们可以看到路由器准备对他进行转发，因为它是要到目的网络 192.168.3.0 的，而 R2 路由器里面的这条聚合路由就包含了网络，这条聚合路由的下一跳是 10.0.0.1，也就是 R1，所以 R2 路由器会把这个 IP 数据包转发给 R1。我们看一下这是他准备转发，然后又层层给它封装起来，最终封装成以太网的帧，我们看一下封装细节，我们主要关心的这里面的 TTL 我们发现当他要离开 R2 路由器以后，它的生存时间被减了一，也就是每过一个路由器它会减一跳。

那么我们继续捕获，现在他进入了路由器 R1，我们再来看一下又是层层解封，然后这边要把它转发出来。我们先看一下它入站的时候生存时间还是 6，那么出站的时候封装的时候生存时间就是 5 了。那么我们再来看一下它到底是转发到哪里去？那么在我们 R1 路由器里面的话， IP 数据报它把它的目的地址取出来是 192.168.3.1，那么在这个里面的话没有一条匹配记录，它只会走默认路由，而这个默认路由告诉我们的是下一跳跳到 10.0.0.2，也就是 R 路由器的接口，所以 IP 数据报会再从 R1 发回到 R2。

​![](https://image.peterjxl.com/blog/image-20220103154507-qleqnru.png)​

​![](https://image.peterjxl.com/blog/image-20220103154519-13t01o2.png)​

同理了，这个 IP 数据报还会再次发给 R1， R1 又会发给 R2，就这样来回的反复在 R1 和 R2 之间转发，直到这个 IP 数据报的 TTL 值为 0，那么我们再前进几步。现在我们可以看到 R1 在收到 IP 数据报以后，层层解封以后，他发现数据包的 TT L 值到期了，我们看一下他进来的时候是 1，那么路由器再把它减一，准备转发的时候发现 TTL 值为 0，所以这个时候就会把他丢弃了，丢弃以后我们可以看到这里还有一个红色的，那么这个是表示在我们这儿也写了，这个 R1 的路由器会向他丢弃的他所丢弃的这个 IP 数据报的发送方，发送 ICMP 的时间超过的这样的一个通知报文。

​![](https://image.peterjxl.com/blog/image-20220103154601-ysqrmvq.png)​

这样的话当通知报文到达主机 H2 以后，我们主机 H2 里面发送之前的 IP 数据报的进程就可以知道，原来是他的所发送的 ID 数据报在路由器 R1的时候， R1 把它给丢掉了。

---

那么如何解决 IP 数据报在路由器 R1 和 R2 之间反复的转发。这种路由环路问题，我们应该在 R1 路由器的路由表中，针对192.168.3.0/24 这个不存在的网络，针对它添加一条所谓的黑洞路由，也就是说到 192.168.3.0/24，这个不存在的网络去的话，如果数据包要去到这儿的话，那么让路由器直接转发给他自己的 null0 接口，null0 接口是一个虚拟的接口，你可以认为是 IP 数据报进到这个接口以后就不会再出来了，有去无回。那也相当于是 R1 就把这个 IP 数据报给它丢弃掉了。

我们现在就来给 R1 路由器添加这条黑洞路由，点击路由器，然后进入到命令行界面回车，然后我们输入以 ENABLE 然后我们输入 CONFIG 再回车。下面我们就进入到了这种配置模式，然后我们给它设定一条黑洞路由命令是 ip ROUTE 路由，给定它的网络地址 192.168.3.0，相应的地址掩码是通过 24，我们就知道有 24 比特连续的一，剩下 8 比特连续的 0 写成点分 10 进制形式，255.255.255.0，然后空格再给一个 NULL0。指名下一跳交到哪里，这个接口本身是不能配 IP 地址的。这个意思是说给 R1 添加一条路，由路由到目的网络是 192.168.3.0，相应的地址掩码三个 255 一个 0，而下一跳，应该跳到 NULL0 这个接口。我们回车，这样就要配置完成了

```
Router>enable 
Router#config
Configuring from terminal, memory, or network [terminal]? 
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#ip route 192.168.3.0 255.255.255.0 null0
```

‍

下面我们就再让主机 H2 给不存在的网络的某一台主机，再次发送一个 ICMP 的报文，当然它是封装在 IP 数据报中进行发送的，那么我们先把之前的这些实验场景给它删除掉，我们点击右下角的箭头，然后点击这儿的删除，这些场景就被删除掉了。

---

下面我们再来发送一个复杂的 PDU 那点主机 H2，然后目的 IP 地址就是这个不存在网络当中的，例如是 192.168.3.1，源 IP 就是主机 H2 的我们不用填了， TTL 直默认 32 就可以了，序号我们写一，单次仿真时间也写 1。好创建 PDU 我们最好把鼠标状态再切回选择状态。下面我们就点捕获前进。

ICMP 的报文被封装在 IP 数据报以后发送出来了，那么 R2 查找路由表，那么由于它 IP 数据报是到 192.168.3.1，也就是属于网络，而这个网络其实是聚合在了 R2 路由器里面的这条聚合路由所指示的目的网络里面的，所以 R2 会把它按照下一跳 10.0.0.1 也就跳给 R1，转发给 R1，我们来看一下。

那么当这个 IP 数据报转发到 R1 以后， R1 把它删除了。

​![](https://image.peterjxl.com/blog/image-20220103173822-1liuir3.png)​

我们来看一下细节，这个 IP 数据报进来以后，从以太网的帧层层解封到网络层，网络层解封到这个程度以后，他准备去转发了，所以他就要构建转发的包。但是他转发的时候发现他的转发表里边有一条匹配的路由记录，也就是这条黑洞路由。而这条黑洞路由的下一跳，是一个 null0 接口，所以路由器 R1 就会把这个数据包给丢弃掉。这样的话呢就我们就会看到，被丢弃以后就不会在 R1 和 R2 之间 IP 数据报反复被转发，这样就要不存在环路问题了

​![](https://image.peterjxl.com/blog/image-20220103173834-gyt4bxg.png)​

实验就要进行到这里了，希望通过本实验，您对聚合了不存在的网络，而导致静态路由的路由环路问题有了更深刻的理解，并且已经学会了使用黑洞路由来解决这种问题的方法
