---
title: 实验15 网络故障导致的路由环路问题
date: 2022-10-14 18:01:52
permalink: /Network/lab14-Routing-Loops-3/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
feed:
  enable: true
description: 下面我们来进行一个仿真实验，本仿真实验的目的在于验证由于网络故障而导致静态路由的路由环路问题。
---



# 150.实验15：网络故障导致的路由环路问题

下面我们来进行一个仿真实验，本仿真实验的目的在于验证由于网络故障而导致静态路由的路由环路问题。

<!-- more -->

我已经在软件中构建好了我们理论课中所用到的网络拓扑，并给网络中的各个设备配置了相应的 IP 地址和地址掩码。对于网络中的各个主机，我们还给他们指定了默认网关，例如主机 H1 的默认网关，就是路由器 R1，具体就是路由器 R1 的接口。对于网络中的各个路由器，我们还给他们添加了静态路由，例如只给路由器 R1 添加了一条默认路由，而给路由器 R2 添加了两条，一条是到达主机 H1 所在的网络的静态路由，另外一条是到达主机 H3 所在网络的这条静态路由，他们的下一跳都应该跳给路由器 R1 的接口。

​![](https://image.peterjxl.com/blog/image-20220103174931-5keyn8r.png)​

下面我们首先来验证一下我们所做的配置工作是否全部正确。我们用主机 H2 去 ping 一下主机 H1，那点击主机 H2，然后选择桌面选项卡，然后选择命令行。我们 ping 一下 H1，它的 IP 地址是 192.168.1.1：ping 192.168.1.1。

现在开始 ping，第一个请求超时，第 2 个也超时，第 3 个受到响应了，第 4 个也收到响应了。这两个超时是由于之前有 ARP 的广播请求，也就是请求相应的 IP 地址与对应的 MAC 地址。那么我们再次 ping 一下，这回应该是 ping 收到了 4 个响应：

```
C:\>ping 192.168.1.1

Pinging 192.168.1.1 with 32 bytes of data:

Request timed out.
Request timed out.
Reply from 192.168.1.1: bytes=32 time<1ms TTL=126
Reply from 192.168.1.1: bytes=32 time=4ms TTL=126

Ping statistics for 192.168.1.1:
    Packets: Sent = 4, Received = 2, Lost = 2 (50% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 4ms, Average = 2ms
```

下面我们首先来验证一下我们所做的配置工作是否全部正确。我们用主机 H2 去 ping 一下主机 H1，那点击主机 H2，然后选择桌面选项卡，然后选择命令行。我们 ping 一下 H1，它的 IP 地址是 192.168.1.1：ping 192.168.1.1。

现在开始 ping，第一个请求超时，第 2 个也超时，第 3 个受到响应了，第 4 个也收到响应了。这两个超时是由于之前有 ARP 的广播请求，也就是请求相应的 IP 地址与对应的 MAC 地址。那么我们再次 ping一下，这回应该是 ping 收到了 4 个响应。

那么我们再测试一下主机 H2 和 H3 的是否能够 ping 通 PING 主机 H3 的 IP 地址是 192.168.2.1。第 1 个请求超时，第 2 个就可以收到响应，第 3 个第 4 个都可以，第 1 个也是因为 ARP 的原因，我们再测试一下，这回应该可以连续收到 4 个响应。这样的话我们就首先确保了我们各个设备所配置的 IP 地址以及路由器配置的静态路由都是没有问题的。

```
C:\>ping 192.168.2.1

Pinging 192.168.2.1 with 32 bytes of data:

Request timed out.
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.2.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

---

我们来查看一下路由器 R1 的路由表，在这里为了简单起见，我们就采用界面的方式而不去命令行去查看，我们点击右侧的查看按钮，然后再点击路由器 R1，然后选择路由表。这就是 R1 的路由表，那么我们把它调整一下，方便我们的查看。

​![](https://image.peterjxl.com/blog/image-20220103175537-toeaqxj.png)​

* 那么第一条 0.0.0.0.0/0 就是我们事先添加的那条默认路由，也就是说 R1 它要收到一个去往其他网络的数据包，当然是去网和它非直连的，例如在这个图里面的就是主机 H2 所在的网络，他下一跳应该把这个数据包转发给 R2 路由器，具体就是 R2 的接口。
* 第二、第三条：那么下面路由这两条记录其实都在表明， R1 要通过自己的接口直连的是这一段网络，也就是 10.0.0.0，那么具体是自己的 10.0.0.1 就是接口直连的。  
  10.0.0.0/30  
  10.0.0.1/32
* 第 4，第 5 条：192.168.1.0/24 这一条表示一个直连网络是左边主机 H1 所在的网络，那么它和 R1 是直连的，并且 R1 直连的端口是 192.168.1.254，就是这一条。
* 第 6，第 7 条  192.168.2.0/24        192.168.2.254/32       最后这两条是代表主机 H3 和 R1 的接口直连的。就是最后这两条

---

假如现在连接 H1 这一段链路出现了故障，或者是 R1 的端口它当掉了，那么会出现什么样的情况，我们来把鼠标先切换到选择模式。然后我们假如说就是 R1 的端口它当掉了，我们把它打开，这个端口事先我们已经查看了，是端口 1，在配置这个地方，我们找到端口 1，然后它本身是要打开的，我们模拟一下把它关掉，也就是说它出现故障了：

​![](https://image.peterjxl.com/blog/image-20220103201908-nympudg.png)​

我们注意一下路由表会发生什么样的变化，我们把它关掉，我们可以看到路由表里面对应网络和接口的那两条路由信息就要没有了：

​![](https://image.peterjxl.com/blog/image-20220103201915-t8wwyy8.png)​

​![](https://image.peterjxl.com/blog/image-20220103202358-nd4cm94.png)​

---

在这种情况下，我们再来让主机 H2 给主机 H1 发送一个 ICMP 的询问报文，我们看看会出现什么样的情况。很显然主机 H1 肯定是收不到的，因为这一条链路有问题，或者说 R1 的端口被我们当掉了，但是除此之外，还会发生什么现象，我们来进行单步仿真一下。我们从实时模式切换到仿真模式，然后我们不需要仿真软件帮我们监听这么多的协议，那么我们把他们全部隐藏掉，然后我们只选择一个 ICMP 协议就可以了。现在我们让主机 H2 给 H1 发一个 ICMP 的报文，那也就是选择这个地方添加简单的 PDU 然后指定 H2 是源主机，然后目的主机 H1。下面我们就要捕获前进，这是单步的点击一下，首先发给他的默认网关 R2，默认网关 R2 查找自己的路由表决定应该是转发给 R1。

到达 R1 以后， R1 也要进行转发，那么他把 ICMP 的报文，当然它是封装在 IP 数据报里面的，它把它的目的 MAC 地址目的 IP 地址提出来，发现是 192.168.1.1，然后他就在这里面去查表，结果他找不到一条匹配的路由，他就只能走事先给他配置好的默认路由，也就是下一项它会跳给 10.0.0.2，具体的就是 R2 的接口，我们看一下是不是这样。果然他就要转发给 R2 了。

当然 R2 查完这个取出 ICMP 的目的，IP 地址是要去往 H1 的，也就 192.168.1.1 查他的路由记录就是第一条匹配，所以他就又会转发给 10.0.0.1，也就会给 R1。

这样的话 ICMP 的报文它就在 R1 和 R 的这两个路由器之间的来回转发，直到它的 TTL 值减为 0 为止。

我们来看一下，当他进入路由器的时候，它的 TTL 值已经变成 249 了，它最初主机发出来的时候应该是也就是 H2 把它发出来的时候，这个地方应该是 255，然后到了路由器 R2，然后又到 R1，刚才我们又转发了几次，所以每过一个路由器它会减一。那么我们看一下他要再把它 R2 要把它再转发出来的时候，TTL  
值应该再减一，确实是那 248，所以在 R2 和 R1 之间来回这种转发，直到 IP 数据报，它里面的生存时间减少到 0，这个时候路由器就会把它丢弃掉。那么应该如何避免这种情况的发生？

---

您可能已经想到了使用我们上次课程中就已经使用过的黑洞路由，我们可以对 R1 的直连的网络以及上面网络添加相应的黑洞路由。为了简单起见，我们就要添加现在我们演示的出故障的网络。我们进入到 R1 的命令行界面，然后按下回车键，那输入 enable，再输入 config 进入全局配置模式，然后这里回车一下就可以了。我们给它配一条黑洞路由，也就是接口它所连的网络，我们给它配成黑洞路由，那么命令是 IP route 然后 ，这就是后面要输入目的，网络是 192.168.1.0 就是网络。然后 地址掩码就是由于这儿我们看到主机 H1 和路由器 R1 的接口，后面斜线都是 24，肯定应该就是 24 个比特 1，剩下 8 个比特的 0 写成点分十进制，三个 255 一个 0 那么最后下一跳，我们让他跳给 null0 接口：

```
Router(config)#ip route 192.168.1.0 255.255.255.0 null0
```

‍

注意观察一下，当我把这一条路由添加以后，用命令行的方式添加以后，我们这儿看到的路由表应该有这一条相应的记录。这一条路由我们就要添加进来了，那么这里面它没有出现。我们把它关掉，重新查看一下，看有没有，然后选择右侧的查看按钮，再来查看路由器的路由表。我们就可以看到我们刚才添加的一这一条黑洞路由就出现了

现在我们就再来验证一次，看看主机 H2 给主机 H1 发送 ICMP，数据报的时候，是否还会在 R1 和 R2 之间的来回转发，我们先把鼠标切回到选择状态，然后我们点击右下角的箭头，把我们刚才做的实验场景给它删除掉。下面我们就选这儿的添加简单的 PDU 我们让主机 H2 给主机 H1 发送，然后我们捕获前进，进行单步的仿真。H2 把 ICMP 的报文传输给了他的默认网关 R2，R2 查表第一条记录就符合，所以就转发给 R1。

到达 R1 以后，我们可以看到很明显 R1 是把它给丢弃了，为什么是丢弃了？其实 R1 是把它取出来，把它的目的 IP 地址取出来，是 192.168.1.1，然后去查表查他的路由表，发现这条路由记录的是匹配的，就把它转发给了 null0 接口。其实就相当于把收到的 ICMP 报文给它丢弃掉了。

​![](https://image.peterjxl.com/blog/image-20220103202959-hdvff31.png)​

---

我们再把这个实验场景给它删除掉，如果说我们现在再把这个端口给它恢复了，看看有什么情况，我们再次点击路由器 R1，然后我们到它的配置界面，然后刚才我们关掉这个接口是一号接口，我们把它再打开，然后我们看一下会它的路由表里面会出现什么情况？

打开，我们会发现这里面我们刚才添加的那条黑洞路由不见了，而又多出来了网络的路由也就是在这儿又多出来这两条就是网络的路由。

​![](https://image.peterjxl.com/blog/image-20220103203035-ofm5zvq.png)​

那么我们再次来看一下，如果我们再把端口给它当掉，那么选择一号接口，我们再把它给它关掉。我们会发现刚才那两条表示直连网络的那两条路由没了，而我们配置的那条黑洞路由就要重新出现了，也就是说路由器与它直连的这些网络，通过它的各个接口的 IP 地址和地址掩码它是知道的，到达这些直连网络属于直接交付，他会在自己的路由表里面有相应的路由记录。例如我们现在看到 R1 和 H3 所在的网络就是相应的路由记录，这两条 192.168.2.0，这个是表明是他自己的接口。一旦它直连的一些网络出故障的话，那么他就无法得出这样的路由，例如我们现在 H1 所在的网络，在这里面你就看不到 192.168.1.0，那应该是他直连的每一个接口的记录。

但是，我们会看到这是我们事先给他配置好的一条到达网络的一个黑洞路由。也就是说如果它的直连网络正常的时候，那么它路由表里面有效的就是直连网络的那条路遥，如果直连网络出现故障的话，那么直连网络的路由就会消失掉，如果我们之前配置了相应的黑洞路由，此时黑洞路由就会生效。

​![](https://image.peterjxl.com/blog/image-20220103202939-5tzphcj.png)​

本仿真实验就进行到这里了，相信您对由于网络故障产生的静态路由的环路问题有了更深刻的理解，并且已经掌握了使用黑洞路由的方法来避免这种环路问题的出现
