---
title: 实验9：划分子网
date: 2022-10-09 19:01:52
permalink: /Network/lab10-IPv4-Subnet/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
feed:
  enable: true
description: 下面我们来进行一个仿真实验，本仿真实验的目的在于帮助大家加深对 IP 地址第三个历史阶段，也就是构造超网的理解
---


# 100.实验10：构造超网（无分类编址）

下面我们来进行一个仿真实验，本仿真实验的目的在于帮助大家加深对 IP 地址第三个历史阶段，也就是构造超网的理解  
构造超网也称为路由聚合，它使用无分类编制的方法。

‍<!-- more -->

‍

首先我们介绍一下本仿真实验的具体内容，构造如图所示的网络拓扑。网络中包含 4 个网络，假设给每个网络分配 1 个地址块：

​![](https://image.peterjxl.com/blog/image-20240530102831-rwilre3.png)​

‍

‍

请根据各网络所分配的地址块完成以下工作，以便实现各主机间的相互通信：

* 第一，给各主机分配一个 IP 地址，并设置子网掩码
* 第二，给各路由器的各接口分配一个 IP 地址，并设置子网掩码
* 第三，给各主机指定默认网关，也就是默认路由器
* 第四，给各路由器配置静态路由，并且进行进一步的路由聚合

我们先对题目进行分析，我们需要写出各网络所分配地址块的详细信息，这在理论课中已经详细介绍过了。先看 192.168.16.0/25 这个地址的话，根据斜线后面的数字 25 可知网络前缀为 25 个比特。

因此将前 25 比特固定不变，而剩余 7 比特全部清零，这就是该地址块的最小地址，写成点分十进制形式为 192.168.16.0，地址块的最小地址也作为网络地址。

将前 25 比特固定不变，而剩余 7 比特全部之一，这就是该地址块的最大地址，写成点分 10 进制的形式为 192.168.16.127，地址块的最大地址也作为广播地址，由于网络地址和广播地址都不能分配给主机或路由器，因此，可分配给主机或路由器的地址范围为 192.168.16.1 到 192.168.16.126。根据斜线后面的数字 25 可知地址掩码有 25 个，连续的比特 1，剩余 7 个连续的比特 0。写成点分 10 进制形式，为 255.255.255.128。

再来看 192.168.16.128/26 这个地址框，根据斜线后面的数字，26 可知网络前缀为 26 个比特，因此将前 26 比特固定不变，而剩余 6 比特全部清零，这就是该地址块的最小地址，写成点分十进制这个形式为 192.168.16.128。地址块的最小地址也作为网络地址。

将前 26 比特固定不变，而剩余 6 比特全部置 1，这就是该地址块的最大地址，写成点分十进制的形式为 192.168.16.191，地址块的最大地址也作为广播地址，由于网络地址和广播地址都不能分配给主机或路由器，因此可分配给主机或路由器的地址范围为 192.168.16.129 ~ 192.168.16.190。

根据斜线后面的数字 26 可知地址掩码有 26 个连续的比特 1，剩余 6 个连续的比特 0，写成点分十进制形式为 255.255.255.192，相信大家可以很快的写出另外两个地址块的详细信息。

---

现在我们已经得出了各网络的地址掩码以及可分配 IP 地址的范围，我们先给上面网络分配，该网络中有两个主机和一个路由器接口，他们的地址掩码都为 255.255.255.128，我们可以从 192.168.16.1\~192.168.16.126，这个地址范围中，为各主机及路由器接口分配 IP 地址，例如我们给网络中的这台主机分配的 IP 地址为 192.168.16.1，给另一台主机分配的 IP 地址为 192.168.16.2，可将分配地址范围中的最后一个地址也就是 192.168.16.126，分配给路由器接口。当然你也可以自行分配，只要在可分配地址范围内选择地址就可以了。

再来给下面网络分配。该网络中有两个主机和一个路由器接口，他们的地址掩码都为 255.255.255.192，可从 192.168.16.129 \~ 192.168.16.190，这个地址范围中为各主机及路由器接口分配 IP 地址，例如我们给网络中的这台主机分配的 IP 地址 192.168.16.129，给另一台主机分配的 IP 地址为 192.168.16.130，将可分配地址范围中的最后一个地址，也就是 192.168.16.190 分配给路由器接口。

接下来我们给两个路由器之间的这道链路，也可以看作是一个网络进行分配，该网络中仅有两个路由器接口，他们的地址掩码都为 255.255255.252，该网络可分配的 IP 地址只有 192.168.16.193 和 192.168.16.194，因此给该网络中的两个路由器接口各配置其中一个 IP 地址即可。

最后我们给最右侧的网络分配，该网络中有一个主机和一个路由器接口，他们的地址掩码都为 255.255.255.252，该网络可分配的 IP 地址只有 192.168.16.197 和 192.168.16.198。因此，对该网络中的主机和路由器接口各配置其中一个 IP 地址即可。

​![](https://image.peterjxl.com/blog/image-20220102154033-a7xmhke.png)​

---

现在请您思考一下，同一网络中的各主机之间，主机与路由器接口之间，各路由器接口之间是否可以直接通信？答案是可以通信。再来思考一下上面网络中的某个主机和下面网络中的某个主机，它们之间是否可以直接通信？答案是不可以通信，这是因为他们处于不同的网络，他们都需要将数据包发送给各自网络上的默认路由器，由默认路由器帮他们进行转发默认路由器要称为默认网关。左边的这台路由器既是上面网络的默认网关，也是下面网络的默认网关。

对于上面网络中的各主机，我们为其指定的默认网关的地址，是左侧路由器上面这个接口的 IP 地址，也就是 192.168.16.126，对于下面这个网络中的各个主机，我们为其指定的默认网关的地址是左侧路由器下面这个接口的 IP 地址，也就是 192.168.16.190，对上下两个网络中的各主机指定了默认网关后，他们之间就可以相互通信了

不要忘记，还有最右侧这个网络中的主机也应该为他指定默认网关，右侧路由器就是它的默认网关，我们为他指定的默认网关的地址是右侧路由器，右边这个接口的 IP 地址，也就是 192.168.16.197，请再想想看上面网络中的某个主机或下面网络中的某个主机是否可以与最右侧的主机进行通信，答案是不可以通信。这是因为图中的两个路由器并未使能路由选择协议，也就是并不使用路由算法，他们仅知道与他们直接相连的有哪些网络。

路由器可以根据自己的各接口所分配的 IP 地址和地址掩码，知道自己都与哪些网络直接相连。

例如左侧的这台路由器，他知道自己的上面这个接口与网络 192.168.16.0/25 直接相连。

自己的下面这个接口与网络 192.168.16.128/26 直接相连，自己的右侧这个接口与网络 192.168.16.192 斜线 30 直接相连，但他并不知道右侧的网络 192.168.16.196/30 如何到达，甚至可以说他并不知道网络的存在，这就需要我们对它进行配置，告诉他如果数据包要到达网络，192.168.16.196/30，可以将数据包转发给右侧这个路由器，也就是指定下一条地址为右侧路由器的左边接口的地址，也就是 192.168.16.194。

同样的道理，相信您可以很快得出右侧这台路由器的路由表，对于直接相连的网络，路由器可以自行得出，而最后两行所示的非直接相连的网络及下一跳地址需要我们进行配置，这次各主机间就完全可以通信了。

​![](https://image.peterjxl.com/blog/image-20220102154415-juv92o4.png)​

最后请您再思考一下，右侧路由器的路由表中的最后两条路由是否可以聚合为一条路由，以便减少路由表中的路由记录数量，这样就可以减少对存储器空间的占用，并且可以提高查找路由表的速度。我们在理论课中已经介绍过，采用找出共同前缀的方法来进行路由聚合，这里就不再赘述了。最终聚合的地址块为 192.168.16.0/24。

---

我已经在软件中构建好了我们之前所讲解的网络拓扑，那么这里我们可以看到交换机的各个接口指示灯是橙色的，那么下面交换机也是。那么我们切换一下右下角的实时和仿真按钮，直到它们变为绿色。但是我们现在看到路由器的各个接口仍然是红色，这是因为我们现在的路由器的各个接口仍然处于关闭状态，等一下我们再给路由器各接口配置 IP 地址的时候，顺便把它打开就可以了。

另外路由器需要大家注意一下，我在这里选择的路由器是 2911 这个型号，如果不选这个的话，可能它的接口是不够用的。为了我们稍后对各主机和路由器进行配置的方便，我已经将我们之前所分析的结果都标注在了各个主机以及路由器各接口的旁边。

​![](https://image.peterjxl.com/blog/image-20220102172732-gjy41kj.png)​

---

下面我首先给主机设置 IP 地址和子网掩码，注意一下，我们先不指定各主机的默认网关。我给左边最上面的左上角的这台主机设置 IP 地址，左键点击它，然后选择桌面，然后这里有 IP 配置，给他的 IP 地址就是这里的 192.168.16.1，那子网掩码是三个 255 一个 128，当我们点击的时候，它会自动给一个 C 类的默认的子网掩码，我们修改一下，把最后 0 改成 128

​![](https://image.peterjxl.com/blog/image-20220102172026-iennaxx.png)​

请您依次给各个主机按照我们之前的方法去配置 IP 地址和子网掩码这里我就不再详细演示了。下面我们来给路由器的各个接口配置 IP 地址和地址掩码。

---

> 这里需要注意一下，由于本身我们给各个主机和路由器标注了很多内容，所以我将这个软件它本身默认显示的端口或者是接口号以及设备的型号，比如说路由器的型号，主机的型号以及它们的名称，它本来是默认显示的，我都把它关闭了。那么在这里在菜单栏选择选项，然后参数选择，我们可以看到我把这个显示设备型号设备名称以及在空间中逻辑工作空间中显示端口标签这些内容我都把它选掉了。
>
> 但是我把这一项点开了，也就是当鼠标在逻辑空间中的设备上悬停时，会显示端口标签，这个是很重要的。因为我们现在要给路由器的各个端口去配置 IP 地址，那么我们可以看一下，当我打开以后，这儿点击配置以后，我可以看到它有这么多的接口，有 012 有三个接口，但是这 012 分别是对应的上右下的这三个是哪一个具体对应，那么我们现在还不知道，所以当我把鼠标放到接口的指示灯上，我们就可以看到这是 0 号接口，那放到这儿我们可以看到这是 2 号接口，放在下面我们可以看到这是一号接口，这样我们就可以对路由器的各个接口进行 IP 地址和地址掩码的配置了。

那么我们先来配置左边路由器，我们鼠标左键把它点开，然后在配置选项卡里面我们进行配置。那么我们首先来配上面这个端口，这个端口刚才我们的已经知道它是 0 号端口，所以我们选择这儿 0 号端口。首先上来我们可以把它这个地方的端口状态或者叫接口状态给它点开，所以我们可以看到这个时候路由器下面的接口指示灯变成绿色了。然后 IP 地址就是我们之前分析的 IP 地址，也就是 192.168.16.126，然后子网掩码我们给它设置成它会默认给你一个，但是我们所要求的是三个 255，一个 128，所以把这改掉 128。

然后我们回车一下，另外需要说明的是这里我们为了方便没有去进入到命令行的模式，我们刚才这个动作设置 IP 地址和子网掩码，其实相应的也可以用命令行命令的方式，就是这一条 IP address，然后给 IP 地址和后面的子网掩码。这样端口 0 的 IP 我们就设好了。

​![](https://image.peterjxl.com/blog/image-20220102172254-zaqskpr.png)​

下面我们设下面这个端口的下面这个端口，刚才我们看到应该是端口 1 的，首先我们也是把它打开，然后 IP 地址是我们在这已经标出来了，192.168.16.190、那子网掩码他会给一个 3 个 255，1 个 128，这个和我们所需要的这儿需要配置的是 3 个 255，1 个 192 这个端口接口我们也配置完了，

​![](https://image.peterjxl.com/blog/image-20220102172441-3xn5374.png)​

那么最后在路由器的右侧的接口，也就是 2 号接口，那么首先我们把它打开，然后这个接口我们看这儿写的是 IP 地址 192.168.16.193，子网掩码的话，我们这儿是三个 255，一个 252，那么把它自动生成的改成 252，好回车，这样路由器我们就配置完了，也就是它的各个端口的各个接口的 IP 地址和指导员我们已经设置完了。

​![](https://image.peterjxl.com/blog/image-20220102172518-kvlmh3v.png)​

请您按照之前我们介绍的方法，将路由器的这两个接口配置 IP 地址和子网掩码，我们这里就不具体的去演示了。

---

那么到这里我们已经给各个主机配置了 IP 地址和子网掩码，以及给各个路由器的各个接口的配置了 IP 地址和地址掩码。那么下面我们就来看一看，按道理讲上面这两台主机之间应该可以通信，下面这两台主机之间应该可以通信，我们来验证一下是不是这样子的。

我们用上面的左边这台主机把它点开，然后选择命令提示符，然后我们去 ping 一下，我们用左边主机去 ping 右边主机的 IP 地址 ping 192.168.16.2。我们看到有 4 个响应，也就是从我们 ping 的 IP 地址收到了 4 条响应证明这是通的：

```
C:\>ping 192.168.16.2

Pinging 192.168.16.2 with 32 bytes of data:

Reply from 192.168.16.2: bytes=32 time<1ms TTL=128
Reply from 192.168.16.2: bytes=32 time=6ms TTL=128
Reply from 192.168.16.2: bytes=32 time<1ms TTL=128
Reply from 192.168.16.2: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.16.2:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 6ms, Average = 1ms
```

‍

‍

那么再用下面左侧的主机去 ping 右侧的主机。我们来看一下 ping 空格，192.168.16.130，好。也是从我们所 ping 的 IP 地址收到了 4 条响应，这代表了也是通的。

```
C:\>ping 192.168.16.130

Pinging 192.168.16.130 with 32 bytes of data:

Reply from 192.168.16.130: bytes=32 time<1ms TTL=128
Reply from 192.168.16.130: bytes=32 time<1ms TTL=128
Reply from 192.168.16.130: bytes=32 time<1ms TTL=128
Reply from 192.168.16.130: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.16.130:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

‍

那么想想看上面网络中的主机和下面网络中的主机，他们之间不通，应该是不通的，我们来验证一下，我们用上面这个主机，我们用上面这个主机来 ping 一下下面这个主机， ping 192.168.16.129。正在进行 ping 的过程，会发 4 个请求过去第一个请求超时了，没有受到响应，第二个所发生的请求也没有收到，对方回答的响应也是超时了。第三个同理，4 个请求都没有收到相应的响应，这个就表明上面和下面是不通的：

```
C:\>ping 192.168.16.129

Pinging 192.168.16.129 with 32 bytes of data:

Request timed out.
Request timed out.
Request timed out.
Request timed out.

Ping statistics for 192.168.16.129:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

‍

---

其实我们之前已经介绍过了，这是因为我们给主机和下面这些主机都没有指定默认网关，下面这个主机要把数据包发给下面这个主机，它首先就会判断下面主机和自己不在同一个网络，所以下面这个主机首先就要把数据包的发送给默认网关，由默认网关的帮他转发，但是由于我们之前没有给它设置默认网关，所以就会导致它其实不知道把数据包该怎么发送了，那么现在我们就给他**指定默认网关**，这样从图上可以看出来主机的默认网关或者说默认路由器就是最左侧的路由器，那么我们将路由器的端口也就是和这台主机在同一个网络中的端口告诉主机，那么我们点开它，然后点 IP 配置，这里面的话在这儿默认网关，把它默认的 4 个 0 给它去掉，那么我们改为这个地方的 192.168.16.126

​![](https://image.peterjxl.com/blog/image-20220102173012-ozu6d9z.png)​

同理，我们给下面主机也指定一个默认网关，它的默认网关其实也是这台路由器，只不过是接下路由器下面这个接口和它处于同一个网里，所以我们就应该把下面这个接口作为它的默认网关的地址。我们点 IP 配置把原来默认的 4 个 0 给它修改为默认网关的这个地址，也就是接口的地址。这个接口是 192.168.16.190。我们给上面这台主机已经指定了默认网关是路由器的接口，给下面这个主机也指定了它的默认路由器是这个路由器，当然我们指定的是下面接口的 IP 地址：

​![](https://image.peterjxl.com/blog/image-20220102173040-oktzeun.png)​

现在的话理论上来讲，上面和下面这两台主机之间应该是可以通信了，那么我们来看一下是不是这样子的。我们现在就用上面这个主机来 ping 一下下面这个主机，ping 空格，然后 192.168.16.129 回车。那么第一次请求超时了，第 2 次请求回来了，第 3 次请求也有响应回来了，第 4 次请求也有响应回来了：

```
C:\>ping 192.168.16.129

Pinging 192.168.16.129 with 32 bytes of data:

Request timed out.
Reply from 192.168.16.129: bytes=32 time<1ms TTL=127
Reply from 192.168.16.129: bytes=32 time<1ms TTL=127
Reply from 192.168.16.129: bytes=32 time<1ms TTL=127

Ping statistics for 192.168.16.129:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

‍

证明上面这台主机和下面这台主机现在已经可以通信了，那么为什么第一次的 ping 的请求会超时，是因为第一次存在这样一个问题，我们这台主机首先他要判断他所发送的数据包的目的地址，也就是这台主机的目的地址，和他自己不在一个网络，所以他就应该把数据包交给他所在网络的默认路由器，换句话说他要把数据包发给 Ip 地址，于是他就在他自己的高速缓存里面去 ARP 的高速缓存里面去查找，但是他找不到这个 IP 地址对应的 MAC 地址。所以他首先发了一个 ARP 的广播请求，路由器在收到广播请求以后发现问的是自己的接口的 MAC 地址，路由器就会给这个主机发一个 ARP 的单播响应，把自己的 MAC 地址告诉他。

同理当路由器要把数据包转发出来给主机的时候，路由器也在自己的 ARP 高速缓存去查这台主机的 IP 地址对应的 MAC 地址，刚开始也是没有的，会发一个 ARP 广播请求，主机收到以后给路由器一个 ARP 单播响应，之后路由器才能把数据包重新封装出来发给这台主机。所以这样的一个过程就造成了我们的听的应用程序的超时。但是一旦第一次这个过程完成以后，那么第二次就不存在这一段这一个网络中的 ARP 的广播请求和响应，也不存在这一段网络中的 ARP 广播请求和响应，数据包就是从主机发出来，那么通过交换机在到达路由器查表，立刻就转发到交换机，又转发到这台，主要这样就不会超时了。

---

那么请您按照我们各个主机旁边所标注的默认网关，给其他剩余的这三台主机都配置默认网关，那么我这里就不再详细演示了。我已经将剩余的这三个主机的默认网关也配置好了。下面想一想下面网络中的任何一个主机或者下面网络中的任何一个主机，能不能和最右侧网络中的这台主机进行通信？理论上是不行的，我们实际来验证一下，看是不是这样。那么我们假如用左上方这台主机来 ping 一下最右侧的这台主机，它的地址是我们 ping 一下，就是主机的 IP 地址 192.168.16.198：

```
C:\>ping 192.168.16.198

Pinging 192.168.16.198 with 32 bytes of data:

Reply from 192.168.16.126: Destination host unreachable.
Reply from 192.168.16.126: Destination host unreachable.
Reply from 192.168.16.126: Destination host unreachable.
Reply from 192.168.16.126: Destination host unreachable.

Ping statistics for 192.168.16.198:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

‍

‍

我们会得到这样一条消息，这个消息的话我们可以看到响应来自于哪里？来自于 192.168.16.126。那来我们是上面主机给下面主机发请求报文，但是我收到了响应是来自于 Ip 地址的，这个 IP 地址我们看一下在这里面就是路由器的接口，说白了就是当主机给主机发送数据包的时候，数据包先到了路由器，而这个路由器会向我主机进行一个报告的什么呢？目的主机不可达。换句话说，之前上面主机要发给右侧主机的数据包，首先到达了路由器下面就要把它进行转发，但是路由器不知道如何转发，所以路由器没法转发它就不转发了。同时他会把这个事情再告诉这台主机，也就给主机发一个数据包，告诉他你刚才发给我的数据包我没有办法，我不知道如何把它转发出去。

路由器是根据自己的路由表，然后对接收到的数据包进行转发的。那么我们说之前我们刚才也看了，路由器收到了主机发来的数据包，但是路由器不知道怎么去转发，来不知道怎么去转发到这台主机，我们看一看是不是这样子的。我们再点击查看，然后查看一下路由器的路由表，那么我们可以看到在路由表里面，192.168.16.0/25 实际上指的是上面网络，192.168.16.128 指的是下面网络，这里还有一个 192.168.16.192.30 指的是网络，也就是路由器它直接相连的这三个网络他自己是知道的。

​![](https://image.peterjxl.com/blog/image-20220102173417-vevik5z.png)​

另外我们在这里面还可以看到斜线 32 的有三条记录，实际上是分别记录了他自己的这三个接口的 IP 地址。那么这个路由器和它自己直接相连的三个网络他是知道的，但是我们刚才是主机要把数据包发给主机，也就数据包要到达网络，而这个网络的话对于路由器左边的路由器来说，它根本就不知道，我们可以说它甚至不知道网络的存在，所以需要我们手工指定给他。

那么我们之前就已经分析过了，那么我们需要给他指定到这个网络，也就告诉他有这样的一个网络，所以说有这样一个目的网络 192.168.16.196，然后相应的地址掩码是三个 255，一个 252，并且告诉他要到达网络去的话下一跳，应该跳给他右侧的路由器的接口，也就是跳给 IP 地址为 192.168.16.194 的这个接口，我们在这儿也标出都标出来了接口。那么下面我们就对这个路由器，我们给它添加一条静态路由，那么我们先把鼠标状态切回到选择状态，然后点击这个路由器，那么在这个里面配置选项卡里面，我们可以看到在路由下面有一个静态，那么在这里面就可以添加静态路由，那么我们就把这一条添进来，网络是 192.168.16.196，那掩码 255.255.255.252，那下一跳地址是 192.168.16.194，然后点击添加，我们就可以看到我们告诉他的一条，要到达网络去，要通过这个地址也就下一跳要转发给这个 IP 地址。

​![](https://image.peterjxl.com/blog/image-20220102173734-0v5aw95.png)​

那么我们再点击右侧查看按钮，我们在打开路由器的路由表看一下，那么我们可以看到这一条 s 就代表静态的，也就是我们刚才添加的那一条路由，也就是到达网络去下一跳，我应该跳给这样的一个 IP 地址。

​![](https://image.peterjxl.com/blog/image-20220102173751-j2hplhx.png)​

那么请您按照我们给这一台路由器配置静态路由的方法，给这一台路由器添加两条静态路由，一个是到目的网络这个目的网络去的，另一个是到目的网络这个目的网络去。注意，先不要管下面路由聚合的事情，就给路由器添加这样两条。需要说明的是上面这一条静态路由，其实是告诉路由器如何到达上面网络，也就是说它的下一跳应该跳给这个接口。

那同理，下面这一条静态路由实际上是告诉我，路由器如何到达下面网络，那么他也是应该通过这接口，那也就是下一条地址应该跳给他，最终才能到达下面网络。

​![](https://image.peterjxl.com/blog/image-20220102173853-kyse32n.png)​

现在的话我们把鼠标状态切换回选择状态，然后我来给路由器添加这两条静态路由，点开它以后，选择静态，我们先添加第一条就是 192.168.16.0，这是网络，那么它的相应的地址掩码是三个 255，然后 128。下一跳地址是 192.168.16.193，然后我们点击添加。

接着我们再来把下面这一条静态路由也配置进去，下面这一条是 16.128，把这改成 128，然后掩码这是 192，把这儿改成 192，下一跳，不变，下一跳，仍然是刚才我们说的路由器的右侧接口，好大家再点添加，这样的话我们就给路由器配置了两条静态路由，现在理论上讲整个拓扑结构中的这 5 台主机，它们相互之间都是可以通信的。

---

那么我们来验证一下比较关键的就是上面主机和右侧这个主机或者下面这个主机和右侧主机他们是否能够通信了？那么我们就用右上方的主机，我们来 ping  一下最右侧的主机，那也就是 ping 192.168.16.198，然后我们来看一下，我们可以看到在经过两次的超时以后，我们从所 ping 的目的 IP 地址收到了响应，那么这里面超时的原因也是我们之前就分析过的，存在于在各个网络上进行 ARP 的广播发送和单播响应的回送。我们下面再重新 ping 一次的话，按键盘的上键可以不用再重复输入命令，然后回车。我们就可以发现上方的主机 ping 右边的主机就没有超时了，完全可以 ping 得通的：

```
C:\>ping 192.168.16.198

Pinging 192.168.16.198 with 32 bytes of data:

Request timed out.
Request timed out.
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.198:
    Packets: Sent = 4, Received = 2, Lost = 2 (50% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

‍

那同理我们再用右侧主机 ping 一下下面这个网络中的某个主机，我们点开它，然后选择命令行，比方说我们去 ping 这台主机，那就是 ping 192.168.16.130。我们可以看到直接就从这个目的 IP 地址连续收到了 4 个响应，我们听了他发了 4 个请求那，一次回来 4 个响应，这里没有发生第一次超时的问题，这是因为我们刚才用上面这台主机在 ping 下面这台主机的过程中，这个网段已经用了 ARP 这个网段上也用了 ARP 这个网段上用了，那么我们之后用这台主机去 ping 这台主机的话，实际上这个网段和这个网段都没有用，ARPP 只存在于这一个网段，但是 ARP 所造成的时间的消耗，它在我们 ping 的响应回来的超时时间之内，所以就不会产生超时。

总之我们看到用右侧的主机，ping 下面这个主机是也可以 ping 得通的：

```
C:\>ping 192.168.16.1

Pinging 192.168.16.1 with 32 bytes of data:

Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

---

最后我们来看一下有关**路由聚合**的事情，我们之前给路由器配置了两条静态路由，一条是路由，这个是告诉我路由器上面网络如何到达的，还有一条是下面这一条静态路由，也就是告诉路由器下面这个网络如何到达。那么其实这两个网络我们对于路径这条路路由器来说的话，我们可以看它下一跳，都是相同的，都是接口。从图上我们也可以很容易看出来，这个路由器的数据包要转发到上面或者下面，其实它都应该把这个数据包转发给路由器。所以我们现在可以把这两条的路由给它合并成一条路由。

我们之前在理论讲解中也说过如何去合并静态路由，也就是找这两个目的网络的共同前缀，找到以后就把他们共同前缀，我们发现最后我们得出来是 24 位，最后合并的路由的就是 192.168.16.0/24，相应的由于这个是 24 的话，它的地址掩码就 24 个 1，然后剩余 8 个 0 写成 10 进制，255.255.255.0，他们的下一跳是不变的，其实路由聚合相当于把上面网络所占用的地址块和下面网络所占用的地址块，给它合并成为一个更大的地址块，而数据包反而是要到达上面这个地块和到达下面这个地块的，都要通过路由器也相当于到达更大的地址块，也是通过这一个路由器的，所以我们可以把它们这两个网络地址块给它合并成这一个。下面的话我们就来把之前的这两条给它合并成一个我们点掉的静态，我们看到这个是我们之前我们添加的：

​![](https://image.peterjxl.com/blog/image-20220102174057-0g6sykw.png)​

那么先验证一下，我们把它都删除掉，删除掉以后，那么我们主机和这个主机右边主机就应该 ping 不通上面主机，我们来看一下， ping 192.168.16.2，我们看一下这一条消息，我们注意一下是说从这个 IP 地址 192.168.16.197 得到了一条响应，响应的内容是目的主机不可达，也就是什么意思？我们主机在 ping 主机的过程中，数据包它肯定先要交给它的默认网关，而默认网关现在由于它的路由表，刚才这两条静态路由被我们删了，所以他并不知道如何到达网络去，所以他就要把这个事情告诉我们这台主机，我们可以看到它是通过接口来通知我们这台主机的，而这个接口的 IP 地址就是 192.168.16.197，也就是我们大家看到的，他从这个接口给我们发送的目的主机不可达的消息。那么现在我们就把刚才删除的这两条合并为这一条，我们再给他配置一条，然后聚合以后的路由。

我们来看一下这个是 192.168.16.0、然后掩码是 255.255.255.0。下一跳地址就是这个路由器是这边路由器的接口，好就我们标注的也就是这个地方的 IP 地址，192.168.16.193，然后我们添加。这样的话路由器有一条聚合的路由，就是把到达网络和到达网络的这两条路由距合为一条路由，说白了到达更大的地址块，还是要路由器把数据包发给路由器的接口。那么下面我们再用右边的主机 ping 一下上面主机 ping 192.168.16.2。现在我们就可以看到了我们这台主机去 ping 这个主机，那么我们收到了来自 192.168.16.2，也就这台主机的响应发了 4 个请求，收到 4 个响应证明是通的：

```
C:\>ping 192.168.16.1

Pinging 192.168.16.1 with 32 bytes of data:

Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

‍

‍

我们再验证一下，用最右侧主机 ping 一下下面这个主机，可能下面这个网络它是否可以到达 ping 192.168.16.130。我们看到也是依次收到了来自 192.168.16.130，也就是这台主机的 4 次响应，这就证明了路由聚合是成功的。

```
C:\>ping 192.168.16.198

Pinging 192.168.16.198 with 32 bytes of data:

Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.198:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

本次仿真实验进行到这里就结束了，该仿真实验它的配置内容比较多，因此您在进行实验的过程当中出错的机会，比如说 IP 地址配置错误，子网掩码配置错误，或者是默认网关配置错误，又或者是静态路由添加错误，都可能导致您所做的实验现象和我这里所做的实验现象不一致的情况。这时候就请您需要自行去分析到底是因为什么原因产生的，往往就是由于这个地址或者是路由的配置错误产生的。

‍
