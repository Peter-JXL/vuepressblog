---
title: 实验17 开放最短路径优先OSPF
date: 2022-10-16 18:01:52
permalink: /Network/lab17-OSPF/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
feed:
  enable: true
description: 下面我们来进行一个仿真实验，本仿真实验的目的在于验证OSPF协议的作用
---



# 170.实验17：开放最短路径优先OSPF

下面我们来进行一个仿真实验，本仿真实验的目的在于验证 OSPF 协议的作用。

<!-- more -->

我已经在软件中构建好了这样一个网络拓扑，并且在每个设备的旁边都标注了所需要配置的 IP 地址，为了简单起见，本实验所采用的 IP 地址为主类 IP 地址，也就是采用默认子网掩码的分类 IP 地址，如果您还不会构建这样的网络拓扑，请您参照上次课的仿真实验，也就是有关 RIP 协议的仿真实验。

下面请您思考这样几个问题：

如果这三台路由器运行的都是 RIP 协议，那么这台主机和上面这台主机，他们之间通信的数据包应该走哪一条路由？

如果这三个路由器运行的是 OSPF 协议，那么同样的下面主机和上面主机，它们之间通信的数据包是否会和 RIP 一样走相同的路由？还是说与 RIP 不同走另外一条路由？

​![](https://image.peterjxl.com/blog/image-20220104202615-imepkdw.png)​

根据我们上一次课有关 RIP 协议的介绍以及仿真实验，我们知道 RIP 协议他会选择低速链路这样一条路由，因为相对这样一条路由来说的话，那么只过两个路由器比过三个路由器距离更短，我们这儿的距离是指的路由器的数量，尽管这样的一条路由上面有一段低速的链路，但 RIP 协议认为这样的一条路由仍然是好的路由，因为 RIP 协议他只关心距离，也就是从源网络到达目的网络中间的路由器的数量

如果是 OSPF 协议，则会认为这样一条路由才是好的路由。因为 OSPF 协议它是基于链路状态的，所谓这种状态就是路由器它与邻居路由器之间的代价是多少，那么 邻居离路由器是否可达？那么对于思科的路由器，它计算这个代价是通过用 100 兆的带宽去除以链路本身的带宽，像我们这里面这两个路由器之间的这段电路，它是 1G 的带宽，这两个路由器之间它也是 1G 的带宽，那么我们用 100 兆去除以这段电路的 1G，那么得到的是 0.1，但是我们把它记作为一。同理，那么这一段的代价也是一，所以从网络要到达网络，那么走这样一条路由，它的开销就是 2。

而如果要走这样一条低速路由，这个地方是一条低速的链路，如果你用 100 兆的带宽去除，以它的这一段低速电路的带宽的话，你得到的代价是远远大于我们刚才说的这样的一条路由的代价为二的，这个数值会非常大。

因此 OSPF 它路由选择协议一定会使得从网络要到达网络的数据包会从路由器拿到路由器，再到这个路由器。接下来我们来看一下 OSPF 协议他是不是会选择这样一条路由。

---

我们首先需要给各个主机配置 IP 地址，并指定默认网关，然后给这三个路由器各个接口配置 IP 地址，最后使能他们的 OSPF 协议。对于主机上面的 IP 地址的配置，它是取决于主机所运行的操作系统，例如 WINDOWS 系统、LINUX 系统或者是苹果的 MAC OS 操作系统，那么它没有一个统一的这样的界面或者是统一的命令，因此在我们仿真软件里面，我们就通过仿真软件的界面对它配置就可以了。比方说点击上面这个主机，然后选择选项卡、里面的桌面，然后这儿有一个 IP 配置，然后把我们标注在旁边的这些 IP 地址信息给它相应的填进来，给它配置好就可以了。例如比如说我们给主机分配的 IP 地址是 192.168.0.1，那么我们在这儿就给它设置为相应的 192.168.0.1，然后我们这儿的子网掩码就填 C 类的默认子网掩码就可以了。

然后再把默认网关的接口的 IP 地址 192.168.0.254，那么给它输入进来就可以了。再给这两台主机配置完 IP 地址和默认网关以后，我们需要给这三台路由器的各个接口也配置相应的 IP 地址，那以及地址掩码。在我们以前的仿真实验当中，为了简单起见，我们对路由器的各接口的 IP 地址都是通过这样的一个界面的方式，比方说在这儿这个就是路由器的接口 0，那么我们先把接口状态打开，然后输入 IP 地址，然后是子网掩码，在实践当中也就是实际工作当中实际上是不存在这样一个界面的，我们需要切换到命令行的方式来对它进行配置

那么下面我们就来演示一下如何通过命令行的方式给路由器的各个接口配置 IP 地址和子网掩码。首先我们为了区分路由器不同的接口，我们在菜单栏的这儿的选项，然后选择参数，然后在这把在逻辑工作空间中总显示端口标签这一项给它选中，这样的话我们就可以看到路由器的每个接口都会有一个接口号，比如说这个接口的话，它是串口 0-0-0，这个是千兆的以太网口 0/1，这个是千兆的以太网口 0/0，只不过设备自动显示出来的端口标签会挡住我们标注在旁边的这些 IP 地址，那么我们稍微调整一下就可以了。那么右边这个路由器的话，那么它的这两个端口由于靠的比较近，所以它自动显示出来的端口号有重叠，我们仍然区分不了是哪一个，所以我们可以拖动一下。现在我们大致就可以看出来，那么这个口是 0 号口，这个口是一号口。我们再把它拖放回来。那么上面路由器的端口容易区分这个口是串口 0，这个口是千兆的以太网的一号口，这个上面是千兆的以太网的 0 号口，那么他把 IP 地址阻挡了，我们把它拖下来。

我们以上面这台路由器为例，来介绍一下如何通过使用命令给路由器的各个接口配置 IP 地址和地址掩码。我们点击这台路由器，然后选项卡选择命令行界面，这就是路由器的命令行配置界面，那么我们把这个窗口把它置顶，这样我点击到仿真软件的其他地方，这个界面它始终不会消失，它会显示在界面的最前方。

现在命令行问我们说是否要进行初始化配置，那么我们输入一个 NO，回车，这样的话他提出我们按回车键就可以进行配置了，我们按回车键。那么在这样的一个命令提示符下面，我们输入 enable 进入到特权模式，然后我们再输入 CONFIG 然后回车这样我们就要进入到了全局的配置模式，

那么我们先来配置路由器上面的接口，那么具体的命令是 interface 端口的全名叫做 gigabit 吉比特，然后 ethernet 以太网，然后他的号码是 0/0，所以我们输入 0/0，  
这样我们就进入到了接口的配置模式。那么同理这个地方它显示的也是进入到了接口的配置模式，这个地方的 IF 实际上是 interface 的缩写代表接口，而不是程序员比较熟悉的条件语句。  
然后我们就给它配置 IP 地址和地址掩码，具体的命令是 IP address 192.168.0.254， 输入子网掩码或者叫地址掩码，那么具体的它是一个 C 类的，IP 地址 192 就可以看出来，那么我们就用一个 C 类的默认的子网掩码，255.255.255.0，然后我们回车，那么这样接口的 IP 地址我们就要配置完了，我们还要把接口的状态给它变成打开，所以再输入一个命令叫做 NO SHUTDOWN，这样的话这个端口就被开起来了，我们可以看到它的指示灯就变成了绿色的，

接下来我们配置一下接口，然后我们回车，那么我们首先要切换到接口的配置模式，所以我们这儿输入 interface，那么我们其实刚才配置接口的时候，我们用的是完整的命令，现在我可以用一个再演示一下，其实可以用简单的命令，我们不需要把命令打全，那么我们先切换到接口，那 interface 我们就输入一个 int 就可以了，然后它后面本身要跟着这一长串，我们就输入一个 G 就可以了，具体的端口号码是 0/1，所以我们这儿写 0/1，然后回车，这样我们就已经切换到了接口的它的配置模式，int g0/1

我们输入 IP  ADD 20.0.0.1， 然后空格输入它的地址掩码，这是一个 A 类的，从 20 就可以看出来是一个 A 类的这个 IP 地址，所以我们给一个 A 类的默认的子网掩码，然后 255.0.0.0，然后回车，ip add 20.0.0.1 255.0.0.0

不要忘记了，还要把这个接口给它状态给变成开启，也就是 NO SHUTEOWNO

跟这个接口不同，我们把它的打开以后它仍然是红色，这是因为路由器的接口还没有开启。

```
Router>enable
Router#config
Configuring from terminal, memory, or network [terminal]? 
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#interface gigabitethernet0/0
Router(config-if)#ip address 20.0.0.1 255.0.0.0
Router(config-if)#no shutdown
```

‍

接下来我们再配置一下路由器的串行的接口，仍然我们要切换过去 ING ，它的名称我们把它简写为 S0/0/0， 然后回车，接下来就给他配置 IP 地址，IP Add 就可以了，然后它的 IP 地址我们规划的是 30.0.1，那相应的子网掩码的是一个 255 三个 0。

同样的我们要把它的状态给它开启， NO shutdown。好总理他的状态指示灯也没有变成绿色，因为路由器的接口还没有开启。

这样一来我们来看一下，我们原来以前仿真实验里面的简单，我们是通过在仿真软件的提供的配置界面，比如说点配置，然后这是接口 0，我们原来是在这儿选打开，然后把 IP 地址输入进来，子网掩码输入进来，现在我们是通过了命令行的方式来实现的。实践当中就是应该通过命令行的方式，而不可能会出现有界面的方式给你来配置。那么请您将这一台路由器，还有这一台路由器的各个接口的 IP 地址，通过命令行的方式，以命令的方式给他们配置我这里就要不再演示了。

---

再给路由器的各个接口配置好 IP 地址以后，路由器就可以得出它各个接口所直连的网络。那么在以前的仿真实验中，我们都是通过这边的查看按钮，然后点击路由器，然后选择路由表来查看路由器里面的路由条目。那么其实也可以通过命令行的方式来查看路由器的路由表，那么我们这里也演示一下。

首先把鼠标状态切换回选择状态，然后我们选择这台路由器，在他的命令行界面，首先这是我们刚才配置了各个接口，所以现在在某一个接口的配置模式下，那么我们应该模式 退出，输入 EXIT。

那么退出后进入到这是全局配置模式，那么我们还需要退出，输入 EXIT 那么这样的话回车就到了特权模式。

那么具体的显示路由器路由表的命令是受 SHOW IP ROUTE 。这样的话我们就可以看到以命令行的方式，我们也可以看到这个地方列出了路由器的路由条目，那和我们在界面上看到的呢是一样的。需要说明的是实践当中是不会有查看按钮来以这种界面的方式给大家看的，实践当中都是通过命令行的这种方式，通过命令在命令行把它显示出来：

```
Router#show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area
       * - candidate default, U - per-user static route, o - ODR
       P - periodic downloaded static route

Gateway of last resort is not set

     20.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C       20.0.0.0/8 is directly connected, GigabitEthernet0/0
L       20.0.0.1/32 is directly connected, GigabitEthernet0/0
     30.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C       30.0.0.0/8 is directly connected, Serial0/0/0
L       30.0.0.1/32 is directly connected, Serial0/0/0
     192.168.0.0/24 is variably subnetted, 2 subnets, 2 masks
C       192.168.0.0/24 is directly connected, GigabitEthernet0/1
L       192.168.0.254/32 is directly connected, GigabitEthernet0/1
```

‍

那么这两台主机现在是否可以正常的通信？答案是不能，因为现在这三台路由器他们仅知道各自直连的网络，那么我们最开始介绍的是手工给他添加静态路由的方法，也就是把网络添加给路由器，告诉他有这样一个网络存在。下一跳需要跳给路由器这个路由器也就把路由器的接口告诉路由器。那么后来我们又学习了 RIP 协议，那么也就是使能各个路由器的 RIP 协议，或者叫做启动各个路由器接各接口的 RIP 协议，这样让 RAP 协议自动获取到达各个网络的最好的这样的一条路由。

---

我们这一次的实验是为了验证 OSPF 这个协议，所以我们相应的应该把各个路由器的各个接口，它的 OSPF 这个协议给给它启动起来。下面我们以这台路由器为例，来介绍一下如何使能它各个接口的 OSPF 协议，那么我们点击左边这台路由器，然后到命令行界面，我们回车，然后首先输入 en，这是 enable 的简写，我们进入到了特权模式，然后输入 CONF 这是 CONFIG 的简写，然后空格 T 那么我们可以进入到配置模式，然后我们输入一个 router OSPF 然后空格再输入一个数值，这个是进程号。那么我们假如说输入 100，那么你可以随意一般 1~6535 的都可以，然后回车，这样我们就要进入到了 OSPF 协议的配置界面。

那么下面我们就要逐个来启动它各个接口的 OSPF 协议，具体的命令是 NETWORK 实际上就是通道它各个接口所连接的网络。那么比如说它的串口 0 是 30.0.0.0 网络，所以我们这就 30.0.0.0，

然以后应该输入的是反地址掩码跟我们以前使能 RIP 的时候输入地址掩码是不一样的，这个地方输入的是反地址掩码，什么意思？这是一个 A 类网络，它的地址掩码默认的词宝掩码应该是一个 255 三个 0，现在相当于把他的每个位置都给它取反，也就是 32 比特，如果给它化成 32 比特的话，那么它的地址掩码应该是 1 个 255，也就是 8 个二进制比特的一，剩下的就是 24 比特的 0，那么现在把它反过来应该就是 8 个比特的 0，剩下 24 个比特的 0 的全部变成一，所以地址反掩码应该是 0.255.255.255。好这个地方要特别注意，不要输入错了，这个地方是反地址掩码，也就是原来是按 255.0.0.0，现在就应该变成 0.255.255.255。那么有一个简单的方法，就是你用 4 个 255 对应的去把它正常的地址掩码的对应的位置上去做相减，那么得到的就是一个反的这样的一个地址掩码。然后再空格输入一个 AREA，这是区域的意思。

那么我们这里面演示的是 OSPF 它这几个路由器呢是属于同一个 OSPF 区域的，我们在理论课中曾经讲过， OSPF 它可以划分区域，分为主干区域和一般区域，这样它可以限制链路状态更新的分组就在本区域内进行。那么这里面我们就演示一个单区域的假设，它就是主区域，这三个路由器都是同一个主区域，主干区域，所以我们这儿是区域空格 0，让它属于区域 0：

```
Router>en
Router#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#router ospf 100
Router(config-router)#network 30.0.0.0 0.255.255.255 area 0
Router(config-router)#
```

‍

‍

那么这样我们就把接口所在网络这样通告一下，相当于使得路由器的接口的 OSPF 协议。

那么我们在使能下一个比如说这个地方 NETWORK 然后空格 10.0.0.0，网络这个接口连的是网络，那么同样的地址掩码是它的正常的掩码的，反过来也就是 0.255.255.255，然后区域是 AREA 0。

那么下面我们再来使它下面这个接口， NETWORK 192.168.1.0，那么它的地址掩码正常的话应该是三个，这是 C 类的，所以应该是三个 255 一个 0，那么反掩码就应该是 0.0.0.255，那么区域还是区域 area 然后空格 0 回车，那么这样的话我们就把路由器的各个接口的 OSPF 的协议给它启动了。

```
Router(config-router)#network 10.0.0.0    0.255.255.255   area 0
Router(config-router)#network 192.168.1.0   0.0.0.255    area 0
```

那么请您把路由器还有路由器的 OSPF 的协议都给它启动了，我这里就要不再做具体的演示了，

再给各个路由器使能了 OSPF 协议以后，那么它们之间就要交互周期性的交互 HELLO 分组以建立邻居关系之后，他们会通过数据库描述分组，链路状态请求分组，链路状态更新分组以及链路状态更新确认分组这样一系列的分组进行交互，最终使得他们各自的链路状态数据库达到一致，也就是我们说他们达到了同步状态，这样他们在根据链路状态数据库得出一个带权的有向图，然后每个路由器基于这个带权的有向图，来构建自己的最短路径，到达其他路路由器的最短路径，进而形成各自的路由表。

---

我们现在就来查看一下，我们还是用简单方法，用这儿的查看按钮来查看路由器的路由表。

那么我们调整一下，那么路由器的路由表，我们凡是标 C 和标 L 的，我们前面介绍过了，是直连的这种网络和自己的接口的 IP 地址，我们不去看它，那么我们就看一下标了 O 的这个类型标的 O 实际上路由条目就是 OSPF 协议得出来的。那么我们先来看这一条，也就是路由器，它现在通过 OSPF 协议学习到了一个网络，10.0.0.0 在图上就是网络，那么他要到网络来的话，我们可以看到下一跳，他要跳到 20.0.0.2，也就是要跳给路由器的接口，那么这个地方度量写的是 110/20，那么我们解释一下前面 110 是 OSPF 的管理距离，也就是它的可信程度。

如果有同样一条路由信息是通过 RIP 特来的话，它的这个地方应该写 120，那么这个时候其实我们会选择哪一个路由？当然是选择 OSPF 的这一条，因为我们认为它更可信，斜线后面这个数字是计算出来的代价。我们来看一下它为什么计算出来的是 2 ，因为从路由器要到达 10.0.0.0 网络，那么有这一段电路，还有这一段电路，这两段电路都是 1G 的带宽，那么思科路由器它是用 100 兆去除以这段的电路带宽，那么得出来 0.1，1 以下的，他都认为是 1，同理这一块也是 100 兆除以 1G 那算出来的是 0.1，他也认为是 1，所以这个代价加起来就是 2，所以这里写的是 2。

那么这一条路由就是说我路由器要到网络去要下一跳跳给路由器，那么整个的代价是 2。

​![](https://image.peterjxl.com/blog/image-20220104205713-rbl8vpf.png)​

我们再来看一下，这一条的话它是到达目的网络 192.168.1.0，也就是到达网络，路由器到达网络它下一跳，很显然这个地方告诉我们跳的是 20.0.0.2，也是跳这个路由器，那么距离这个地方的三是怎么得出来的？也就是这儿的代价是一，这的代价是一，而这个地方接口是 1000 兆的口是 100 兆的，所以就按 100 兆的算，这个链路是按 100 兆的算，所以它的代价是用 100 兆的带宽除以它本身的 100 兆带宽，所以是一，那这样的话整个的代价 1+1+1 = 3。

---

那么我们再来看一下右边的路由器它的路由表，那么它的路由表的内容我们来看一下比较多，有 4 个通过 OSPF 得出的。那么我们一条一条来看，这个地方 30.0.0.0 也就是路由器到达网络，他下一跳，他告诉我们可以跳 20.0.0.1 也就跳这个接口，就到达了网络，具体的度量也就是代价这个地方是 65。那么我们刚才已经说过这一段链路它是一，那么它现在算出来整个代价 65，我们就可以知道这一段其实它算出来是 64，因为这是一个串行链路，它的带宽非常小，你用 100 兆去除以它计算出来实际上是 64，所以这样这两段加起来是 65。

我们再看一下，他还得出来到达网络还有一条路由，这两条路由是到达同一个目的网络的，那么这条路由它让我们走的是下面这一条，也就是说他下一跳，给的是 10.0.0.1，也就是给这个地方，那么它的代价仍然是 65，也就是这一段的代价是一，这一段的代价是 64，那么这两条都是到达同一个目的网络，只不过下一跳不同，但是他们的代价都相同，所以这两个路由是等价的，所以他应该是在这上面做负载均衡。

那么我们再看一下这一条，到 192.168.0.0，那么也就是到达网络路由器，到达网络，他告诉我们说下一跳应该跳到 20.0.0.1，也就是跳到这里面去，跳到路由器的接口，那么到达最终网络的这个代价是二，因为这个地方计算出来代价是一，而这个地方计算出来也是一。

那么最后这一条是说到下面网络 192.168.1.0，这个路由器它下一跳，应该跳给这个接口，也就是 10.0.0.1，这告诉我们跳到这儿，那代价也是二，因为一这儿的代价是一。

当然我们可以看到还有一条路，比如说要到网络去，它可以走上面这儿，再走下面这儿再走下面，但是这一条路的话，这儿的代价是一，这儿的代价 64，这儿的那代价的是一，加起来是 66，比这一条路比从这儿走过来的代价是二要大很多，所以 OSPF 的最短路径，他当然会选择代价最小的这一条路由。

​![](https://image.peterjxl.com/blog/image-20220104205916-89j7679.png)​

下面我们就来检验一下，看看这台主机是否可以和这台主机正常通信了。

那么我们先把鼠标状态切回到选择状态，然后我们点击这台主机，然后到它的桌面选项卡，然后到它的命令提示符。那么在这里面我们来 ping 一下，我们用这台主机来 ping 一下这台主机。 ping 192.168.0.1，然后回车，按理来说应该是可以 ping 得通的，因为各个路由器已经找好了这些到达各个目的网络的路由，只不过我们这里边看到它总共会连续的 ping 4次，那么第一次 ping 的时候也就是超时了。那么我们之前就讲过，那么它里面存在一个 ARP 地址解析的这样的一个问题，所以有一次丢包的情况，有的时候你在做其他实验的时候可能还会丢的包的数量更多，都是因为 ARP 的请求造成的。

那之后我们就可以看到收到了三次 192.168.0.1 主机发回来的响应，那么我们再 ping 一次，那应该是发了 4 个请求，那么相应的收到 4 次这样的一个响应，这就代表这 2 台主机可以相互通信。

```
C:\>ping 192.168.0.1

Pinging 192.168.0.1 with 32 bytes of data:

Request timed out.
Reply from 192.168.0.1: bytes=32 time=1ms TTL=125
Reply from 192.168.0.1: bytes=32 time<1ms TTL=125
Reply from 192.168.0.1: bytes=32 time<1ms TTL=125

Ping statistics for 192.168.0.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 1ms, Average = 0ms
```

‍

那么现在我们还想看一下，就是说这两台主机通信的数据包，它到底是走的这条低速电路的，还是走的这边的高速电路？

那么我们前面说过了对 RIP 协议它一定会走这个低速的，为什么？因为这两个主机的话走低速电路的话，中间就间隔这两个路由器，也就是距离为二。但是对于 OSPF 协议的话，它是以这个代价作为度量的，我们计算的电路的代价一一这是 64，所以如果是 OSPF 的话，它应该是一这一段代价加这一段代价，再加这一段代价，比起这段代价加这一段代价再加这一段代价要小很多，所以它一定是这样一条路径这样一个路由。

那么我们来验证一下，看看是不是，那么我们先从实时模式切换到仿真模式，然后这个里面我们不需要让他帮我们监听那么多的协议，我们把他们全部隐藏掉，然后我们只要看一下 ICMP 就可以了，因为我们现在要用 ICMP 协议打一个数据包，那么就选择这个地方添加简单的 PDU 那么它其实就是用 ICMP 协议打的包，我们点击它，然后指定源主机，然后再指定目标主机。这样的话我们点击这个地方的捕获前进，我们看到主机先把数据包发给他的默认网关，然后这个时候他要么从上面转发走，要么从右边转发走，那么现在我们用的是 OSPF 协议，所以他应该是查他的路由表，他的路由表里面那条路由记录一定会把它指向到路由器，我们看一下是不是，确实是这样的，然后路由器再转发到上面的路由器，那么最终路由器转发给目的主机，目的主机收到以后会给源主机发回一个 ICMP 的响应，那么我们再点击下一步，然后到了路由器，那么它应该又是从下面转发右侧这个地方转转下来，然后再转给左边路由器，最后再转发给最初的源主机。

这样我们就要验证了 OSPF 他选择的路由是依据这个代价以走的代价最小来作为好的路由。

​![](https://image.peterjxl.com/blog/image-20220104210509-5qjvlui.png)​

本次实验就到这里结束了，相信您已经深刻体会到 OSPF 协议的作用，以及如何起到路由器的 OSPF 的协议
