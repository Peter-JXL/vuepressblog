---
title: 实验6 生成树协议STP的功能
date: 2022-10-24 18:01:52
permalink: /pages/978feb/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
---
# 实验6 生成树协议STP的功能

　　接下来我们进行一个仿真实验的内容，是验证以太网交换机生成树协议的功能，首先需要构建网络拓扑，我们采用4台以太网交换机，然后将它们连接成一个环路，然后我们选择自动连线类型，让它们连线成一个环路，我们可以看到交换机的各个端口的状态指示灯为橙色的，那么我们切换右下角的实时和仿真模式。

　　‍

　　现在我们可以看到右上角的这台交换机它的端口一处于阻塞状态，而其他各个交换机的连接的端口都已经成了绿色指示灯，表明是正常工作状态，

　　![image.png](https://image.peterjxl.com/blog/image-20211228202539-hdkdkxn.png)

　　‍

　　这就是因为各个交换机他们在后台运行着生成树协议，使得本来他们连接完了物理拓扑上有环路，但是运行了身份证协议以后，某些交换机它会断掉自己的某些端口，也就是阻塞掉某些端口，这样就使得整个逻辑环路不存在了，没有这个逻辑上的环路，虽然物理上的环路仍然存在，但是从逻辑通信角度来讲，它的环境已经断开了。

　　‍

　　‍

　　‍

　　下面我们给拓扑结构添加两台计算机，我们看到用两个计算机的连接上的动画机的接口是橙色的，我们快速的切换一下实时方式和仿真模式。我们可以看到连接上计算机的相应的交换机的端口变成了绿色的，可以正常工作。我们给这两个计算机配置一下IP地址，左边的是192.168.0.1，那右边我们就配置成192.168.0.2，那么这两台主机现在是否可以进行互通呢？

　　![image.png](https://image.peterjxl.com/blog/image-20211228202743-p20xzfo.png)

　　‍

　　‍

　　‍

　　从网络拓扑上看，上面这条链路的话，由于这一点被堵塞了，给交换机的端口被堵塞了，那么肯定不可能从上面通过来，但是我们可以看到从下面这样绕过来是可以通信的。

　　‍

　　那么我们来验证看一下，我们用左边的这台计算机来ping右边这台计算机，那么我们进到左边这台计算机的命令提示符下面。PING空格，右边这台计算机的IP地址是192.168.0.2。

　　![image.png](https://image.peterjxl.com/blog/image-20211228202825-9trp3bh.png)

　　‍

　　我们可以看到收到了响应，来自1920168.0.2的响应，是我们发了4个询问，他回来了，4个响应证明这是通的，

```js
C:\>ping 192.168.0.2

Pinging 192.168.0.2 with 32 bytes of data:

Reply from 192.168.0.2: bytes=32 time<1ms TTL=128
Reply from 192.168.0.2: bytes=32 time<1ms TTL=128
Reply from 192.168.0.2: bytes=32 time<1ms TTL=128
Reply from 192.168.0.2: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.0.2:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

C:\>
```

　　‍

　　那么反过来用右边那台来ping一下左边那台也是通的。

```js
Cisco Packet Tracer PC Command Line 1.0
C:\>ping 192.168.0.1

Pinging 192.168.0.1 with 32 bytes of data:

Reply from 192.168.0.1: bytes=32 time<1ms TTL=128
Reply from 192.168.0.1: bytes=32 time<1ms TTL=128
Reply from 192.168.0.1: bytes=32 time<1ms TTL=128
Reply from 192.168.0.1: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.0.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

C:\>
```

　　‍

　　‍

　　那么我们就已经验证了这两台计算机可以通过这样一条路径，从这边进入到交换机再转发下来，再到这边的交换机再转换上去，然后最后到这边这个主机，这边主机反过来也可以和左边就可以通信，他们可以通过这样一条路径来通信。

　　‍

---

　　‍

　　现在我们模拟一下，如果说这样一条路径当中某个点出了故障或者某几个点出了故障，会出现什么样的情况？这样的点有很多，随便我们把交换机的点给它模拟一下故障，那么我们把这个接口是接口二等于端口二，我们把交换机打开，然后选择它的配置，然后我们选择这端口，在这个地方它的接口状态本来是开的，我们现在把它点掉也就是把它关掉，

　　![image.png](https://image.peterjxl.com/blog/image-20211228203134-e0p7obp.png)

　　‍

　　‍

　　那么我们可以看到整个这一块这一点也会变成红色。再就是整个路这一块就不通了，出了故障了，那么我们还能通信吗？我们可以验证一下，我们用左边的ping右边的，也就拼192.192.168.0.2。看来是不通了，然后这个意思就是请求超时了，在规定时间内我没有收到响应，这是第一次的第二次的一共要拼4次，也就是一共要发4个询问的报文，等待4个询问报文回来。

　　‍

　　‍

　　经过一段时间以后，我们会观察到右上方的交换机原来被他自己生成树协议堵塞掉的端口，一现在他又恢复了正常工作，

　　![image.png](https://image.peterjxl.com/blog/image-20211228203246-0uvb9st.png)

　　‍

　　这是因为我们人为的在这个地方设置了一个故障，使得原来可以通的那条路现在不通了，所以之后这些交换机他们的生成树协议，在共同运作的情况下会发现这个情况，并且交换机它会把它自己的阻塞的端口打开，选择重新构建一条可以通的这两台计算机可以通的这样的一条通路。现在我们再来ping一下，我们用左边的计算机去拼一下右边的计算机，之前我们拼是超时的，那么我们现在听一下192.168.0.2，我们可以看到这是通的，

　　‍

---

　　‍

　　下面我们把之前我们关闭掉的交换机的端口给它打开二号端口，我们把它打开。然后我们切换实时和仿真模式，我们可以看到经过生成树协议的这种算法，最终还是右上角的这台交换机，把自己的端口一给阻塞掉了，但是整个网络仍然是联通的，只通过下面这条通路，整个网络是联通的

　　![image.png](https://image.peterjxl.com/blog/image-20211228203429-6wsz1og.png)

　　‍

　　‍

　　交换机上的生成树协议，在交换机启动后是默认自动运行的，下面我们将这4台交换机的生成树协议给它关闭掉，然后我们再来做后续的实验，我们需要进入到交换机的命令行，以命令的方式来关闭交换机的生成树协议。现在我们以左上方这一台交换机为例。那么我们点击它以后出来的弹出窗口，这儿有一个命令行界面，我们点命令行界面，那么这样我们就可以进入到这台交换机的命令行方式，我们输入回车，然后我们输入 ENABLE也就进入特权模式，然后我们输入CONFIG进入全局配置模式，这里按一下回车就可以了。然后比较关键的命令也就是关闭生成树的命令是no spanning-tree vlan 1，然后一这条命令其实是删除 VLAN1上面的生成树功能，也就关闭这个功能。VLAN的概念我们还没有讲叫做虚拟局域网，我们后续过程中会说，那么暂且是记住一条命令就可以。

```js

Switch>enable
Switch#config
Configuring from terminal, memory, or network [terminal]? 
Enter configuration commands, one per line.  End with CNTL/Z.
Switch(config)#no spanning-tree vlan 1
```

　　‍

　　那么我们回车，这样的话这台交换机的生成树协议就被关闭掉了，那么下面需要将其他的交换机的生成树协议都关闭掉，我们就不再一一做演示了。现在我们看到的情况就是将这4台交换机的生成树协议全部关闭以后的效果，我们可以看到每个交换机的所连接的端口都已经是绿色指示灯，也就是他们都是正常工作

　　![image.png](https://image.peterjxl.com/blog/image-20211228203852-j980p5e.png)

　　‍

　　这就使得本身有物理的环路存在，然后现在这个物理环路又没有被在逻辑上给它断开，那么也就相当于说逻辑上也存在环路，那么这两台计算机之间也就整个网络大的这样的一个逻辑环路。我们前面在讲理论的时候，只要有这个逻辑环路的存在，那么当某个主机发送一个广播帧的时候，那么这个广播帧就会在逻辑环路里面兜圈子，那么它顺时针方向和逆时针方向都会有兜圈的现象，那么永无止境这样兜下去，这样的话就会严重的占用了网络的资源。

　　‍

　　‍

　　我们下面进入仿真模式，来看一下广播帧兜圈子的情况。那么我们选择右侧右边这个工具栏上面的添加复杂PDU然后我们让左边主机发送一个广播，目的IP地址我们填255.255.255.255，原来IP地址就填这台主机自己的192.168.0.1，这儿给个序号1，那儿给1个单次的仿真时间是1秒，然后创建PDU。

　　‍

　　然后下面我们进行捕获，我们就可以看到它就发送一个ICMP的广播通胀转发出来，然后上面交换机收到转发给主机，它还会从下面口袋转发出来，而下面这边交换机从右边口转发出来，上面有一个广播会到达右下角交换机，左边的交换机会把 ICMPP的广播同样的广播发到这边，对交换机会从不同的接口收到两个广播，然后他收到这两个广播，又从他的两个端口又重新发出来，我们就可以看到，这就永无止境的这样的在这里面兜圈子下去了。

　　![image.png](https://image.peterjxl.com/blog/image-20211228204416-wz9ihwx.png)

　　‍

　　我们现在的切换回实时模式，虽然我们在这个效果上看不到在兜圈子，实际上现在有广播的数据包就在这里面兜圈子，顺时针方向一直分成方向，都在兜圈子，那么这就严重的占用了网络的资源，那么我们在此刻我们再用左边这台计算机去拼一下右边这台计算机，看能不能拼通。Ping 192.168.0.2，如果正常情况下他会发4个请求，那么会收到4个响应，现在我们发了第一个请求，ICMP的第一个请求，结果是请求超时，也就是对方没给我响应，第二请求出去，以后小英还是没回来也超时了。第三个，这样我们发了4个ICMPT的请求报文，但是都没有受到响应，证明这个是不通的，那么反过来用右边这个主机去拼一下左边主机，PMG，然后192.168.0.1。我们来看一下，这仍然是不通的，第一个已经超时了，为什么？是因为网络环路里面有广播帧，在这4个交换机中疯狂的在那儿转发，形成这样的环路疯狂的转发，所以就占用了网络的通信资源。这样的话我们网络上本身想正常通信的那些主机就没有办法正常通信了。

　　本次实验就到这里结束了，相信你已经很的理解了网络环路会给网络带来怎样的负面效应，以及生成树协议的作用

　　‍
