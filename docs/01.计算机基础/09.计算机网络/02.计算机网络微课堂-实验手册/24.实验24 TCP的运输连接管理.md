---
title: 实验24 TCP的运输连接管理
date: 2022-10-24 18:01:52
permalink: /Network/lab24-TCP/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
---
# 实验24 TCP的运输连接管理

　　下面我们来进行一个仿真实验，本仿真实验的目的在于验证TCP使用三报文握手来建立连接，使用四报文挥手来释放连接。

　　我们首先来构建一个非常简单的网络拓扑，只需要一台普通的主机和一台普通的服务器，然后将它们直连即可，选择这里的终端设备，然后拖动一台普通的主机到逻辑工作空间，再拖动一台普通的服务器到逻辑工作空间，选择自动连线方式，将主机和服务器连接起来即可。

　　接下来给主机和服务器分别配置IP地址和地址掩码，点击主机在弹出窗口中选择桌面选项卡，配置的IP地址为192.168.0.1，默认子网掩码，255.255.255.0，不用修改  
再来给服务器配置IP地址和地址掩码，点击服务器在弹出窗口中选择桌面选项卡，然后选择IP配置的IP地址为192.168.0.2，默认子网255.255.255.0，不用修改，

　　![image.png](https://image.peterjxl.com/blog/image-20220109153250-jml9px5.png)

　　下面我们来检查一下物理拓扑以及之前的配置工作是否正常。点击主机在弹出窗口中选择桌面选项卡，然后选择网页浏览器，这样我们就打开了仿真软件为我们提供的一个简易的网页浏览器，在地址栏中输入服务器的IP地址，192.168.0.2，然后点击前往按钮或按下回车键，可以看到主机中的浏览器获取到了服务器中的网页内容，这就表明我们的配置工作都是正常的，可以进行下面的仿真实验了。

　　![image.png](https://image.peterjxl.com/blog/image-20220109153305-5ex0rkz.png)

　　‍

　　‍

　　‍

　　‍

　　‍

---

　　对于本仿真实验，我们关心的是TCP的连接建立与释放的过程，至于和浏览器相关的HTTP协议，HTML语言等并不是本仿真实验的重点，您只需要知道本仿真实验所要实现的应用功能，在应用层需要使用HTTP协议，在运输层需要使用TCP协议即可。

　　接下来我们从实时模式切换到仿真模式，监听HTTP协议和TCP协议即可，我们再次点击浏览器中的前往按钮，来看看浏览器访问WEB服务器内容，TCP协议在其中所扮演的角色，可以看到主机现在准备发送一个数据包，我们点击该数据包来看看详细情况。由于HTTP协议需要使用运输层的TCP协议所提供的运输服务，而TCP又是面向连接的，也就是在数据传输之前必须首先建立逻辑连接关系，因此主机尝试与服务器建立TCP连接，我们来看看主机运输层的具体处理，设置TCP连接状态为同步已发送，然后准备一些协商参数，例如可接受的最大窗口值，使用最大报文段容量MSS选项等，发送TCP连接请求报文段，也就是这里显示的SYN报文段，该报文段首部中的SYN标志位被设置为一，首部中的序号字段的值为0，这是主机位自己选择的初始序号，请注意，这只是仿真软件给出的值，实践当中不一定是0，而是一个随机值。确认号ACK字段的取值为0，该字段的值对于本报文段而言其实没有意义，因为本报文段并不是一个确认报文段，这里的数据长度24是指该TCP连接请求报文段的总长度为24字节，由于TCP连接请求报文段不能携带数据，因此这24字节其实就是该报文段的首部长度，TCP首部有20字节的固定部分和最大40字节的选项部分构成，因此可知有四字节是选项部分，具体为三字节的最大报文段容量MSS选项和一字节的填充，使用一字节填充是为了使TCP首部长度能被四字节整除，您也可以点击出站PDU详情选项卡，来查看TCP封包的详情，我这里就不再赘述了。当然TCP连接请求报文段还要封装成IP数据报，IP数据报还要封装成以太网帧才能进行发送，为了把重点放在TCP上，后面我们就不再提及IP数据报和以太网帧的封装了，

　　![image.png](https://image.peterjxl.com/blog/image-20220109153634-crqdn5s.png)

　　‍

　　‍

---

　　点击这里的捕获前进按钮进行单步仿真，可以看到主机发送TCP连接请求报文段给服务器，点击该报文段。我们来看看服务器的处理情况，服务器收到该报文段后，解析出该报文段是TCP连接请求报文段，服务器接受连接请求，进入同步已接收状态，

　　![image.png](https://image.peterjxl.com/blog/image-20220109153907-5n7g2sl.png)

　　‍

　　‍

　　‍

---

　　然后服务器准备给主机发回TCP连接请求确认报文段，也就是这里显示的SYN加ACK报文段，该报文段首部中的SYN标志位和ACK标志位都被设置为一，序号字段的值为0，这是服务器为自己选择的初始序号，请注意这只是仿真软件给出的值，实践当中不一定是0，而是一个随机值。  
确认号ACK字段的取值为一，表明这是对TCP连接请求报文段的确认，因为报文段的序号为0，且不携带数据

　　![image.png](https://image.peterjxl.com/blog/image-20220109153914-kccbd94.png)

　　‍

　　‍

　　‍

---

　　关闭弹出窗口，再次点击捕获前进按钮，可以看到服务器发送TCP连接请求确认报文段给主机，

　　![image.png](https://image.peterjxl.com/blog/image-20220109154049-x6yvfqc.png)

　　‍

　　‍

　　点击该报文段。我们来看看主机的处理情况，主机收到该报文段后，解析出该报文段是TCP连接请求确认报文段，就要进入连接已建立状态

　　然后主机准备给服务器发回一个普通的TCP确认报文段，也就是这里显示的ACK报文段，该报文段首部中的ACK标志位被设置为一，序号字段的值为一，这是因为之前主机所发送的不携带数据的TCP连接请求报文段使用了序号0，因此主机现在发送的 TCP报文段的序号应该为一，确认号ACK字段的值为一，表明这是对TCP连接请求确认报文段的确认，因为报文段的序号为0，且不携带数据

　　![image.png](https://image.peterjxl.com/blog/image-20220109154112-zdap7i0.png)

　　‍

　　‍

　　![image.png](https://image.peterjxl.com/blog/image-20220109154119-x9ch01n.png)

　　‍

　　‍

　　‍

　　‍

　　‍

---

　　再次点击捕获前进按钮，可以看到主机发送普通的TCP确认报文段给服务器，点击该报文段，我们来看看服务器的处理情况，服务器收到该报文段后，解析出该报文段是对TCP连接请求确认报文段的确认，就要进入连接已建立状态，至此主机和服务器都已进入连接已建立状态，他们可以基于已建立好的TCP连接进行数据传输了，

　　![image.png](https://image.peterjxl.com/blog/image-20220109154239-h22zc5p.png)

　　‍

　　‍

　　‍

---

　　再次点击捕获前进按钮，可以看到主机发送HTTP请求报文给服务器，点击该报文可以看到HTTP请求报文使用TCP报文段来封装，并且报文段首部中的Push标志位为一，表明服务器应尽快地将该报文段交付给应用进程，而不再等到整个缓存都填满了，再向上交付。  
ACK标志位为一，表明该报文段还对之前收到的TCP连接请求确认报文段进行了重复确认  
序号字段的值为一，这是因为主机之前发送的普通TCP确认报文段的序号为一，它不携带数据也不消耗序号，  
确认号ACK字段的值为一，这是对之前收到的TCP连接请求确认报文段的确认，因为报文段的序号为0且不携带数据，长度为100，表明该TCP报文段总长为100字节

　　![image.png](https://image.peterjxl.com/blog/image-20220109154432-rckylbj.png)

　　‍

　　‍

　　服务器对收到的HTTP请求做出响应，构建出HTTP响应报文，使用TCP报文段来封装该HTTP响应报文，报文段首部中的序号字段的取值为一，这是因为服务器之前发送的 TCP连接请求确认报文段要消耗掉一个序号，当时选的初始序号为0，且不携带数据，那么现在服务器发送的 TCP报文段的序号就应该取一，确认号ACK字段的取值为101，这是对之前收到的封装有HTTP请求报文的TCP报文段的确认，因为报文段的序号为一，长度为100，因此确认号ACK应当取值为101，数据长度471，表明该TCP报文段总长为471个字节，

　　![image.png](https://image.peterjxl.com/blog/image-20220109154443-4nf835q.png)

　　‍

　　‍

　　‍

　　‍

　　‍

　　![image.png](https://image.peterjxl.com/blog/image-20220109154457-jg9ajz9.png)

　　‍

　　‍

---

　　再次点击捕获前进按钮，可以看到服务器发送HTTP响应报文给主机，主机收到该报文后进行解析，就可以显示出具体的网页内容了。现在主机和服务器间的应用层传输结束了

　　![image.png](https://image.peterjxl.com/blog/image-20220109154633-4a2n4o0.png)

　　‍

　　‍

　　‍

　　主机要发起运输层TCP连接的释放，可以看到主机准备发送一个TCP报文段，点击该报文段查看其详细内容，主机设置TCP连接状态为终止等待一，并准备发送TCP连接释放报文段，也就是这里所显示的FIN加ACK报文段，该报文段首部中的FIN标志位和ACK标志位都设置为一，序号字段的取值为101，这是因为主机之前发送的封装有HTTP请求报文的TCP报文段的序号为一，且长度为100，  
确认号ACK字段的取值为472，这是对所收到的封装有HTTP响应报文的TCP报文段的确认，因为报文段的序号为一，长度为471，

　　![image.png](https://image.peterjxl.com/blog/image-20220109154805-z2fwa8w.png)

　　‍

　　‍

　　‍

　　‍

　　‍

　　再次点击捕获前进按钮，可以看到主机发送TCP连接释放报文段给服务器，点击该报文段。我们来看服务器的处理。  
服务器解析该TCP报文段，发现这是TCP连接释放报文段，于是进入关闭等待状态。由于服务器此时也没有数据要发给主机了，于是又进入最后确认状态，请注意这与我们理论课讲解时稍有不同，理论课讲解时所举例子是处于关闭等待状态的服务器，还有数据要发给主机，

　　![image.png](https://image.peterjxl.com/blog/image-20220109154905-5per16y.png)

　　‍

　　‍

　　‍

　　处于最后确认状态的服务器，还要给主机发送TCP连接释放报文段，也就是这里所显示的FIN加ACK报文段，该报文段首部中的FIN标志位和ACK标志位都设置为一，序号字段的取值为472，这是因为服务器之前发送的封装有HTTP响应报文的TCP报文段的序号为一，长度为471，确认号ACK为102，这是对所收到的TCP连接释放报文段的确认，因为报文段的序号为101，且不携带数据

　　![image.png](https://image.peterjxl.com/blog/image-20220109154938-gau66vu.png)

　　‍

　　‍

　　再次点击捕获前进按钮，可以看到服务器发送TCP连接释放报文段给主机，点击该报文段。我们来看主机的处理，主机解析带TCP报文段，发现这是TCP连接释放报文段，于是进入正在关闭状态，这相当于我们理论课中介绍的时间等待状态，也就是要等待一段时间才进入关闭状态。

　　![image.png](https://image.peterjxl.com/blog/image-20220109155019-kjbie38.png)

　　处于正在关闭状态的主机，还要给服务器发送一个普通的TCP确认报文段，该报文段首部中的ACK标志位设置为一  
序号字段的取值为102，这是因为主机之前所发送的TCP连接释放报文段的序号为101且不携带数据，那么现在主机发送的 TCP报文段的序号就应当为102，确认号ACK为472，这是对所收到的TCP连接释放报文段的确认，因为报文段的序号为472，且不携带数据

　　![image.png](https://image.peterjxl.com/blog/image-20220109155044-dlly4oq.png)

　　‍

　　‍

　　‍

　　‍

　　再次点击捕获按钮，可以看到主机发送普通的TCP确认报文段给服务器，点击该报文段，我们来看看服务器的处理，服务器解析该TCP确认报文段就要进入了关闭状态，一段时间后主机中的TCP也会进入关闭状态，那时TCP连接释放过程才彻底结束

　　‍

　　![image.png](https://image.peterjxl.com/blog/image-20220109155105-8yropg8.png)

　　‍

　　‍

　　‍

　　TCP连接建立和释放的过程还是比较复杂的，尤其是三豹纹握手，四豹纹挥手所使用的7个报文段，其首部中的同步标志位SYN，终止标志位FIN，确认标志位ACK，序号字段，确认号字段的取值，以及这些报文段是否可以携带数据，非常容易弄错，建议在仿真实验的过程中把它们记录下来，以便搞清楚它们之间的关系。

　　最后还需要提醒您注意的是在我们的教学过程中，发现有的同学认为通过这里就可以看出TCP三报文握手建立连接，四报文挥手释放连接

　　![image.png](https://image.peterjxl.com/blog/image-20220109155226-fjg90k1.png)

　　但实际上这是不对的，这里的同一个TCP报文段可能出现在不同行，用来表示该报文段当前在哪个设备上，或该报文段是由哪个设备发往哪个设备，对于本地TCP释放连接，实际上只使用了3个报文段，而不是这里所显示的4个报文段

　　‍
