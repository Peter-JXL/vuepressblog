---
title: 实验15 网络故障导致的路由环路问题
date: 2022-10-24 18:01:52
permalink: /pages/bb5c6f/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
---
# 实验15 网络故障导致的路由环路问题

　　‍

　　下面我们来进行一个仿真实验，本仿真实验的目的在于验证由于网络故障而导致静态路由的路由环路问题。我已经在软件中构建好了我们理论课中所用到的网络拓扑，并给网络中的各个设备配置了相应的IP地址和地址掩码。对于网络中的各个主机，我们还给他们指定了默认网关，例如主机H1的默认网关，就是路由器R1，具体就是路由器R1的接口。对于网络中的各个路由器，我们还给他们添加了静态路由，例如只给路由器R1添加了一条默认路由，而给路由器R2添加了两条，一条是到达主机H1所在的网络的静态路由，另外一条是到达主机H3所在网络的这条静态路由，他们的下一跳都应该跳给路由器R1的接口。

　　‍

　　‍

　　![image.png](https://image.peterjxl.com/blog/image-20220103174931-5keyn8r.png)

　　‍

　　下面我们首先来验证一下我们所做的配置工作是否全部正确。我们用主机H2去Ping一下主机H1，那点击主机H2，然后选择桌面选项卡，然后选择命令行。我们Ping一下H1，它的IP地址是192.168.1.1，PING 192.168.1.1。现在开始Ping，第一个请求超时，第2个也超时，第3个受到响应了，第4个也收到响应了。这两个超时是由于之前有 ARP的广播请求，也就是请求相应的IP地址与对应的 MAC地址。那么我们再次Ping一下，这回应该是Ping4次收到了4个响应。

```js
C:\>ping 192.168.1.1

Pinging 192.168.1.1 with 32 bytes of data:

Request timed out.
Request timed out.
Reply from 192.168.1.1: bytes=32 time<1ms TTL=126
Reply from 192.168.1.1: bytes=32 time=4ms TTL=126

Ping statistics for 192.168.1.1:
    Packets: Sent = 4, Received = 2, Lost = 2 (50% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 4ms, Average = 2ms

```

　　‍

　　‍

　　下面我们首先来验证一下我们所做的配置工作是否全部正确。我们用主机H2去Ping一下主机H1，那点击主机H2，然后选择桌面选项卡，然后选择命令行。我们Ping一下H1，它的IP地址是192.168.1.1，PING 192.168.1.1。现在开始Ping，第一个请求超时，第2个也超时，第3个受到响应了，第4个也收到响应了。这两个超时是由于之前有 ARP的广播请求，也就是请求相应的IP地址与对应的 MAC地址。那么我们再次Ping一下，这回应该是Ping4次收到了4个响应。

　　那么我们再测试一下主机H2和H3的是否能够Ping通 PING主机H3的IP地址是192.168.2.1。第1个请求超时，第2个就可以收到响应，第3个第4个都可以，第1个也是因为ARP的原因，我们再测试一下，这回应该可以连续收到4个响应。这样的话我们就首先确保了我们各个设备所配置的IP地址以及路由器配置的静态路由都是没有问题的。

```js
C:\>ping 192.168.2.1

Pinging 192.168.2.1 with 32 bytes of data:

Request timed out.
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126
Reply from 192.168.2.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.2.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　‍

　　‍

　　‍

　　‍

---

　　我们来查看一下路由器R1的路由表，在这里为了简单起见，我们就采用界面的方式而不去命令行去查看，我们点击右侧的查看按钮，然后再点击路由器R1，然后选择路由表。这就是R1的路由表，那么我们把它调整一下，方便我们的查看。

　　![image.png](https://image.peterjxl.com/blog/image-20220103175537-toeaqxj.png)

* 那么第一条0.0.0.0.0/0就是我们事先添加的那条默认路由，也就是说R1它要收到一个去往其他网络的数据包，当然是去网和它非直连的，例如在这个图里面的就是主机H2所在的网络，他下一跳应该把这个数据包转发给R2路由器，具体就是R2的接口。
* 第二、第三条：那么下面路由这两条记录其实都在表明， R1要通过自己的接口直连的是这一段网络，也就是10.0.0.0，那么具体是自己的10.0.0.1就是接口直连的。  
  10.0.0.0/30  
  10.0.0.1/32
* 第4，第5条：192.168.1.0/24这一条表示一个直连网络是左边主机H1所在的网络，那么它和R1是直连的，并且 R1直连的端口是192.168.1.254，就是这一条。
* 第6，第7条  192.168.2.0/24        192.168.2.254/32       最后这两条是代表主机H3和R1的接口直连的。就是最后这两条

　　‍

---

　　‍

　　假如现在连接H1这一段链路出现了故障，或者是R1的端口它当掉了，那么会出现什么样的情况，我们来把鼠标先切换到选择模式。然后我们假如说就是R1的端口它当掉了，我们把它打开，这个端口事先我们已经查看了，是端口1，在配置这个地方，我们找到端口1，然后它本身是要打开的，我们模拟一下把它关掉，也就是说它出现故障了，

　　![image.png](https://image.peterjxl.com/blog/image-20220103201908-nympudg.png)

　　‍

　　‍

　　我们注意一下路由表会发生什么样的变化，我们把它关掉，我们可以看到路由表里面对应网络和接口的那两条路由信息就要没有了，

　　![image.png](https://image.peterjxl.com/blog/image-20220103201915-t8wwyy8.png)

　　‍

　　![image.png](https://image.peterjxl.com/blog/image-20220103202358-nd4cm94.png)

---

　　在这种情况下，我们再来让主机H2给主机H1发送一个ICMP的询问报文，我们看看会出现什么样的情况。很显然主机H1肯定是收不到的，因为这一条链路有问题，或者说 R1的端口被我们当掉了，但是除此之外，还会发生什么现象，我们来进行单步仿真一下。我们从实时模式切换到仿真模式，然后我们不需要仿真软件帮我们监听这么多的协议，那么我们把他们全部隐藏掉，然后我们只选择一个ICMP协议就可以了。现在我们让主机H2给H1发一个ICMP的报文，那也就是选择这个地方添加简单的PDU然后指定H2是源主机，然后目的主机H1。下面我们就要捕获前进，这是单步的点击一下，首先发给他的默认网关R2，默认网关R2查找自己的路由表决定应该是转发给R1。

　　到达R1以后， R1也要进行转发，那么他把 ICMP的报文，当然它是封装在IP数据报里面的，它把它的目的MAC地址目的IP地址提出来，发现是192.168.1.1，然后他就在这里面去查表，结果他找不到一条匹配的路由，他就只能走事先给他配置好的默认路由，也就是下一项它会跳给10.0.0.2，具体的就是R2的接口，我们看一下是不是这样好。果然他就要转发给R2了，

　　当然R2查完这个取出 ICMP的目的，IP地址是要去往H1的，也就192.168.1.1查他的路由记录就是第一条匹配，所以他就又会转发给10.0.0.1，也就会给R1。

　　这样的话 ICMP的报文它就在R1和R的这两个路由器之间的来回转发，直到它的TTL值减为0为止。

　　我们来看一下，当他进入路由器的时候，它的TTL值已经变成249了，它最初主机发出来的时候应该是也就是H2把它发出来的时候，这个地方应该是255，然后到了路由器R2，然后又到R1，刚才我们又转发了几次，所以每过一个路由器它会减一。那么我们看一下他要再把它 R2要把它再转发出来的时候，TTL  
值应该再减一，确实是那248，所以在R2和R1之间来回这种转发，直到IP数据报，它里面的生存时间减少到0，这个时候路由器就会把它丢弃掉。那么应该如何避免这种情况的发生？

　　‍

---

　　您可能已经想到了使用我们上次课程中就已经使用过的黑洞路由，我们可以对R1的直连的网络以及上面网络添加相应的黑洞路由。为了简单起见，我们就要添加现在我们演示的出故障的网络。我们进入到R1的命令行界面，然后按下回车键，那输入enable，再输入config进入全局配置模式，然后这里回车一下就可以了。我们给它配一条黑洞路由，也就是接口它所连的网络，我们给它配成黑洞路由，那么命令是IP route 然后 ，这就是后面要输入目的，网络是192.168.1.0 就是网络。然后 地址掩码就是由于这儿我们看到主机H1和路由器R1的接口，后面斜线都是24，肯定应该就是24个比特1，剩下8个比特的0写成点分十进制，三个255一个0那么最后下一跳，我们让他跳给null0接口。

```js
Router(config)#ip route 192.168.1.0 255.255.255.0 null0
```

　　注意观察一下，当我把这一条路由添加以后，用命令行的方式添加以后，我们这儿看到的路由表应该有这一条相应的记录。这一条路由我们就要添加进来了，那么这里面它没有出现。我们把它关掉，重新查看一下，看有没有，然后选择右侧的查看按钮，再来查看路由器的路由表。我们就可以看到我们刚才添加的一这一条黑洞路由就出现了

　　‍

　　‍

　　现在我们就再来验证一次，看看主机H2给主机H1发送 ICMP，数据报的时候，是否还会在R1和R2之间的来回转发，我们先把鼠标切回到选择状态，然后我们点击右下角的箭头，把我们刚才做的实验场景给它删除掉。下面我们就选这儿的添加简单的PDU我们让主机H2给主机H1发送，然后我们捕获前进，进行单步的仿真。H2把 ICMP的报文传输给了他的默认网关R2，R2查表第一条记录就符合，所以就转发给R1。  
到达R1以后，我们可以看到很明显R1是把它给丢弃了，为什么是丢弃了？其实 R1是把它取出来，把它的目的IP地址取出来，是192.168.1.1，然后去查表查他的路由表，发现这条路由记录的是匹配的，就把它转发给了null0接口。其实就相当于把收到的 ICMP报文给它丢弃掉了，

　　![image.png](https://image.peterjxl.com/blog/image-20220103202959-hdvff31.png)

　　‍

　　‍

---

　　‍

　　我们再把这个实验场景给它删除掉，如果说我们现在再把这个端口给它恢复了，看看有什么情况，我们再次点击路由器R1，然后我们到它的配置界面，然后刚才我们关掉这个接口是一号接口，我们把它再打开，然后我们看一下会它的路由表里面会出现什么情况？打开。我们会发现这里面我们刚才添加的那条黑洞路由不见了，而又多出来了网络的路由也就是在这儿又多出来这两条就是网络的路由。

　　![image.png](https://image.peterjxl.com/blog/image-20220103203035-ofm5zvq.png)

　　‍

　　‍

　　‍

　　‍

　　那么我们再次来看一下，如果我们再把端口给它当掉，那么选择一号接口，我们再把它给它关掉。我们会发现刚才那两条表示直连网络的那两条路由没了，而我们配置的那条黑洞路由就要重新出现了，也就是说路由器与它直连的这些网络，通过它的各个接口的IP地址和地址掩码它是知道的，到达这些直连网络属于直接交付，他会在自己的路由表里面有相应的路由记录。例如我们现在看到R1和H3所在的网络就是相应的路由记录，这两条192.168.2.0，这个是表明是他自己的接口。一旦它直连的一些网络出故障的话，那么他就无法得出这样的路由，例如我们现在H1所在的网络，在这里面你就看不到192.168.1.0，那应该是他直连的每一个接口的记录。但是我们会看到这是我们事先给他配置好的一条到达网络的一个黑洞路由。也就是说如果它的直连网络正常的时候，那么它路由表里面有效的就是直连网络的那条路遥，如果直连网络出现故障的话，那么直连网络的路由就会消失掉，如果我们之前配置了相应的黑洞路由，此时黑洞路由就会生效。

　　![image.png](https://image.peterjxl.com/blog/image-20220103202939-5tzphcj.png)

　　本仿真实验就进行到这里了，相信您对由于网络故障产生的静态路由的环路问题有了更深刻的理解，并且已经掌握了使用黑洞路由的方法来避免这种环路问题的出现

　　‍
