---
title: 实验8、9、10 IPv4地址  分类地址，划分子网、构造超网
date: 2022-10-24 18:01:52
permalink: /Network/lab8-9-10-IPv4-Subnet/
categories:
  - 计算机基础
  - 计算机网络
  - 计算机网络微课堂-实验手册
tags:
  - 
---
# 实验8、9、10 IPv4地址  分类地址，划分子网、构造超网


![](https://image.peterjxl.com/blog/101.jpg)

讲讲3个实验

# 分类地址

　　下面我们来进行一个仿真实验，本仿真实验的内容来验证分类IP地址的作用，以及对路由器的功能进行初步了解。

<!-- more -->

　　首先我们来构建一个简单的网络拓扑，拖动两台主机到逻辑工作空间，我们选择自动连接类型，将这两台主机互联起来。接下来我们需要给这两台主机各自配置一个IP地址，先给左边的主机进行配置。假如我们配置一个C类的IP地址具体为192.168.0.1，子网掩码采用仿真软件自动配置的就可以了，因为我们暂时还没有介绍过子网掩码的概念。

　　我们来具体看一下我们所分配的 IP地址，从第一个字节就可以看出这是一个C类的IP地址，也就是192就是可以看出这是一个C类的。那么我们知道C类的IP地址以后，我们就知道它前三个字节是表示C类网络的网络号的，后面这一个字节是用来表示这台主机的，那么这个值的取值范围是0\~255，但是0，其实和192.168.0.0一起是表示具体的C类网络的，所以在网络上最小的用来标识主机的 IP地址就是192.168.0.1，  
而这值如果取到了255，那是表示192.168.0 这个C类网络上所有的主机，所以那是一个广播地址。  
因此主机编号这个部分最小的数值取1，最大的取254，这里我们给左边这台主机配置为1，而右边这台主机的话可以从剩下的2~254里面随便挑一个就可以了。

　　下面我们给右边这台主机也配置一个IP地址，我们为了让右边主机和左边主机可以直接通信，因为他们是直接互联的，没有用其他设备连也没有用路由器连。所以为了让他们可以直接进行通信的话，那么我们必须把右边这台主机的这个和左边这台主机的IP地址使他们的网络号部分相等，也就是让他们属于同一个网络里面。所以右边这台主机的IP地址的网络号部分也是192.168.0，而主机号部分刚才我们说了取值是1~254里面选一个，左边这台主机分配的1，那么剩下的就是2~254里面选一个，我们就选2就可以了。而子网掩码我们采用默认的就可以了。

　　接下来我们就验证一下这两台计算机是否可以通信了，我们用这个左边的主机去Ping一下右边这台主机，看看是否能够Ping通。PING然后空格右边主机的IP地址是192.168.0.2。我们听一下看到回答的第1个响应，第2个响应第3个第4个，也就是说我们左边主机依次发了4个询问请求，那么右边的主机收到后每收到1个会回给1个响应给左边的主机，那么发了4个请求回来，4个响应，也表示它们俩之间是可以互通的。

　　‍

```js
C:\>ping 192.168.0.2

Pinging 192.168.0.2 with 32 bytes of data:

Reply from 192.168.0.2: bytes=32 time<1ms TTL=128
Reply from 192.168.0.2: bytes=32 time<1ms TTL=128
Reply from 192.168.0.2: bytes=32 time<1ms TTL=128
Reply from 192.168.0.2: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.0.2:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　‍

　　‍

　　‍

---

　　如果我们将右边的主机的IP地址重新配置一下，使得左右两台主机他们IP地址的网络号部分不相同，也就是说他们属于不同的网络，那么我们再来看看他们是否可以这样直接的就可以通信了。现在我们就来更改一下右边这台主机之前所配置的IP地址，我们把之前配置的IP地址和子网掩码全部给它删除了，然后我们给它设置一个新的IP地址，比如说172.16.0.1，那子网掩码采用默认子网掩码就可以了，那么这个IP地址我们通过第一个字节的172，10进制的值，我们就可以快速的分辨出来它是一个B类的网络，它的网络号是172.16，后面点0.1就是这台主机的主机编号。

　　总之我们知道现在的话左边这个主机是192.168.0.1，右边主机台IP地址指的是172.16.0.1，他们俩已经不在一个网络上了。我们来验证一下这个时候他们俩之间是否可以通信，我们把这台主机点开，也就是在桌面上把它的命令行方式给它打开，这是我们之前就已经打开的。我们Ping一下172.16.0.1。我们可以看到正在Ping第一次的请求没有收到响应而超时了，第二次的请求也没有收到响应，也超时了，第3次也超时了，第4次也超时了，也就是发4次询问都没有收到响应，这就证明了这两台主机现在虽然这么直连了，但是由于他们IP地址配置的不在同一个网络中，所以他们其实是不能通信的，因此这相当于两个不同网络的互联，所以直接这么连是不行的，

　　![](https://image.peterjxl.com/blog/image-20220102102715-9tvv4f7.png)

```js
C:\>ping 172.16.0.1

Pinging 172.16.0.1 with 32 bytes of data:

Request timed out.
Request timed out.
Request timed out.
Request timed out.

Ping statistics for 172.16.0.1:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

　　‍

　　‍

　　‍

　　‍

　　‍

---

　　我们把这条直连线给它删除掉，好然后把鼠标状态再切换回来，那么这两个不同网络的互联，我们需要添加一个三层的设备，也就是路由器，我们直接拖一个路由器上来就可以了。然后我们选择自动连线，我们使用了一个路由器，这是一个网络层的设备，网络层的互联设备，将两个属于不同网络的主机直接给它互联起来了。那么我们需要给路由器的两个接口配置一个IP地址，比如说千兆的以太网的它0号口，我们在配置里面这儿可以看到这个接口，我们可以给它配置一个IP地址，那么这个接口和我们主机的接口，其实它们相当于是在同一个网络中的，所以路由器的接口，它的IP地址的网络编号部分应该和我们这台主机的IP地址的网络编号部分相等，也就是应该是192.168.0这一部分是不能动的，相等的，那么剩下的在给大家分配一个，那么这台主机由于它的主机编号是1，而这个接口的话，我们可以从2~254里面挑一个，一般我们会挑最大的 IP地址，主机编号254，子网掩码采用默认的就可以了。另外我们看到这是红色的，这个接口的现在是关闭的，我们要点击右边的端口状态  
打开，它就变成绿色指示灯了。

　　同理我们要为路由器的右边这个端口设置一个IP地址，也就是一号端口，我们选到它那么和左边配置的道理是一样的，这个右边的接口，它的右边主机的IP地址，它们应该是网络号部分相同的，因为它们处在从一个网络上，所以右边这个主机的IP地址是172.16这是，它的网络号部分这一部分不能动，剩下的话还有两个十进制的值都是作为主机号的，那么主机上我们用的是0，然后是1，那么我们取最大的网络上可以取最大的主机编号，那么第三个字节就是255，最后一个是254。注意一下，最后不能填255，如果填255的话，相当于是172.16网络上，然后它的主机号填成了两个255，那就相当于是广播地址了。

　　那子网掩码的我们采用默认的就可以了，我们忘了打开这个端口了，我们再把它打开一下，那么下面我们再来看看这两台主机能不能通，那么我们仍然用左边那台主机来Ping一下右边这台主机还是。我们这样Ping一下，我们之前就是Ping 172.16.0.1，也就这台主机的IP地址我们听一下。看第一次Ping超时了，第一次询问请求没有按照时间回来超时了，第二次也超时了，第3次还是超时啊，第4次也是超时，想一想这是为什么呢？其实是因为左边这台主机他要给右边这台主机发送询问报文，那么他首先会判断，也就是他首先会判断我们这儿给定的172.16.0.1 IP地址，通过这个IP地址他自身会去判断和自己是不是在同一个网络中，那么当他判断出来172.16.0.1和自己的192.168.0.1，这两个IP地址其实他们不在同一个网络中，那么这个时候我们的左边主机他就知道他的数据包不可能直接发送到目的地，他需要把这个数据包交给一个路由器帮他去转发。

　　![](https://image.peterjxl.com/blog/image-20220102103812-citlv07.png)

　　‍

　　‍

　　‍

---

　　那么由于这个路由器我们没有告诉他说这个数据包你应该交给谁，也就这个路由器我们没指定给他，所以他这个时候就没有办法把这个数据包转发出去了。所以那么我们再重新给它配置一下我们点主机，然后把之前的命令行界面给它关掉。再回到IP配置的界面，我们可以看到这个地方有一个默认网关，默认网关其实就是我们之前说的计算机主机要把数据包转发出去，他发现数据包的目的IP地址，你自己根本不在同一个网络，那么他就会把这个数据包必然需要交给一台路由器帮他转发出去，而这个路由器我们一般称为是默认路由器，但是由于历史的原因，默认录用期的概念最早它把它称为默认网关，所以很多软件包括我们的WINDOWS系统都称为是默认网关，并没有把它称为是默认路由器。

　　这里知道一下就可以了，所以我们这里面应该给他指定也就是给这台主机，虽然我们给他配的IP，但我们还要告诉他，如果你这个数据包你要发送的数据包，他所到达的那个地方目标主机和你自身不在同一个网络，你要通过哪一台路由器把它送出去？那么由于这台主机和这台路由器的0号端口，他们在同一个网络，所以我们其实相当于是把路由器的0号端口的配置的IP地址告诉这台主机，也就是默认网关这个地方，我们要设置一个IP，这个IP就是路由器的端口0的我们之间配置的 IP地址，我记得我们配的是192.168.0.254。

　　同理在我们右边这台主机上我们也没有指定，如果他要发送一个数据包，那个数据包的目的IP地址实际上与主机不在同一个网络，那么它肯定也要交给一个默认的路由器或叫默认网关，帮他转发，这个路由器就是我们现在看的路由器，那么应该指定他的一号端口的 IP地址。那么我们把右边这一台计算机的 IP配置界面打开，默认网关店里面我们就要填写这台路由器的端口一的我们之前配置过的 IP地址，我记得应该是172.16.255.254。下面我们就来再次看一下左边和右边能不能Ping通，我们还是用左边来Ping就可以了。

　　![](https://image.peterjxl.com/blog/image-20220102104136-lyodo2q.png)

　　‍

　　‍

　　‍

　　![](https://image.peterjxl.com/blog/image-20220102104438-un3uh2v.png)

　　‍

　　‍

　　‍

　　再来Ping一下，第1个请求超时了，但是我们看到第2个、第3个、第4个都正常回来了，也就是说我们这边左边的主机依次发送了4个请求报文，那么他每收到1个应该给我们回来1个，只不过我们看到第一个超时讲一讲这是什么原因？其实是因为是这样子的，我们在Ping的过程中，当这个数据包我们要Ping它的话，到达路由器，路由器要去转发，转发的时候这里面还存在一个问题，就是路由器要首先知道右边主机它的接口的 MAC地址，也就我们之前讲过的要先发一个ARP广播请求，把取回来以后才能再次把询问报文转发到这，然后他收到以后再给一个响应回来，那么这个时候路由器再通过查表转发，把单波响应传回来，那么这样的一个过程使得我们的Ping的应用程序，它认为这是一个超时的。为什么之后就可以没有超时，是因为路由器，准备转发请求给右边这台主机的话，不用再进行 AIP的广播请求了，因为之前已经请求过了已经知道了主机的MAC地址，所以就不会超时了。

```js
C:\>ping 172.16.0.1

Pinging 172.16.0.1 with 32 bytes of data:

Request timed out.
Reply from 172.16.0.1: bytes=32 time<1ms TTL=127
Reply from 172.16.0.1: bytes=32 time<1ms TTL=127
Reply from 172.16.0.1: bytes=32 time<1ms TTL=127

Ping statistics for 172.16.0.1:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　‍

　　‍

　　我们可以验证一下，我们再Ping一次应该是很快的4个响应就会回来

　　‍

```js
C:\>ping 172.16.0.1

Pinging 172.16.0.1 with 32 bytes of data:

Reply from 192.168.0.254: Destination host unreachable.
Reply from 192.168.0.254: Destination host unreachable.
Reply from 192.168.0.254: Destination host unreachable.
Reply from 192.168.0.254: Destination host unreachable.

Ping statistics for 172.16.0.1:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),

C:\>
C:\>
C:\>ping 172.16.0.1

Pinging 172.16.0.1 with 32 bytes of data:
```

　　‍

　　到这里相信您对分类IP地址有了更深入的理解，并且对路由器的作用有了初步的认识。给您留一个作业，我们之前将右边的主机的IP地址修改为了一个B类的，IP地址，将路由器的端口1的IP地址也做了相应的修改，只得左边的主机可以对右边的主机进行Ping，并且可以Ping通。那么我们的作业是请您将右边这台主机的IP地址改为一个A类的IP地址，那相应的对路由器的端口1的IP地址也要做修改，我们实现的目标是使得左边的主机可以Ping通右边的主机，也就是说这两台主机可以实现他们之间的通信，

　　‍

# 划分子网

　　下面我们来进行一个仿真实验，本仿真实验的目的在于学习划分子网的方法以及验证子网掩码的作用。

　　我们首先来构建一个这样的网络拓扑，我们需要4台主机，2台交换机，我们选择自动连线的类型让他们互联起来，为了使指示灯从橙色的快速变成绿色，我们快速切换右下角的实时和切换按钮，接下来需要给这4个主机分别设置1个IP地址和子网掩码，我已经将每台主机的IP地址和子网掩码标注在了他们旁边，我们按照标注的值进行设置即可，我们依次来进行设置，192.168.0.1，子网掩码是三个255一个0，这是他默认的子网掩码

　　下面这台主机192.168.0.2多少掩码，也就三个255一个0。右上方的这台主机，192.168.0.65，子网掩码三个255一个0，最后这台主机192.168.0.66，子网掩码三个252一个0，现在这4台主机之间可以相互通信吗？答案是这4台主机可以相互通信，因为通过给定的IP地址和子网掩码，我们可以知道这四台主机是在同一个网络上的，具体分析如下，我们通过给定的IP地址的第一个数，第一个10进制数也就是192，我们就可以看出这是一个C类的IP地址，而给定的子网掩码是三个255一个0，这是C类的默认子网掩码，相当于没有划分子网，因此在给定的IP地址中，前三个字节就是网络号部分，最后一个字节就是主机部分，而我们看到这4台主机的IP地址的前三个字节，也就是前三个数都相等，也就是192.168.0。因此我们可以判定这4个主机他们在同1个网络上

　　也可以这样来判断，将每个主机的IP地址和它自己的子网掩码相与，我们会得到网络号部分以及被清零的主机号部分，其实得到的结果就是主机所在的网络的网络号。同理其他的主机都是这么操作，我们会得到4个网络号，如果这4个网络号相同，那就证明这4台主机在同1个网络上，那么他们之间就可以相互通信。

　　我们可以看一下上面这台主机192.168.0.1和255.255.255.0，相遇的结果是192.168.0.0。同理下面这台主机它的IP地址和子网掩码相余，结果也是192.168.0.0，右边这两台也是同样的结果，这就表明了他们就在同一个网络上，他们是可以直接相互通信的。

　　![](https://image.peterjxl.com/blog/image-20220102105938-wolnvpk.png)

　　‍

　　下面我们就来验证一下这4台主机之间可以相互通信，我们用左下角的这台主机分别去Ping一下它上面的这台，还有它右边这两台主机，它是否可以Ping通。我们到命令提示符。我们现在是下面这台主机的命令行，我们来Ping一下上面这台主机，也就是Ping192.168.0.1。我们看到一次收到响应回来了，有4个响应回来，下面这一台可以Ping通它上面这一台，  
我们再Ping一下它右上方的这一台，也就是192.18.0.65。我们看到也接收到响应了，  
那么我们最后再Ping一下它右下角的这一台192.168.0.66。这样我们可以看到这4台主机应该是可以互相通信的，

　　‍

　　‍

---

　　下面我们将各个主机的子网掩码更改一下，假如说我们给它更改成三个255，然后最后一个数值是192，我这里先把它标注上了。下面我们就来实际的改一下左上这台主机IP地址这个地方改成192，我们把它复制一下，下面这台主机IP配置，然后把这地方粘贴一下。右上方的主机把它的子网掩码也给它改掉。最后右下方这台主机。

　　现在请您思考一下，这4台主机之间是否还能进行相互通信？答案是左边这两台主机之间可以相互通信，右边这两个主机之间可以相互通信，但是左边和右边它们不能相互通信，这是因为左边这两台主机被划分到了一个子网，而右边这两台主机被划分到了另一个子网，我们可以将这4台主机的IP地址与他们自己的子网掩码进行相与，然后得到网络号，我们会发现左边这两台主机，他们会得到相同的网络号，也就是192.168.0.0，说明这两台主机在同一个网络上，而右边这两台主机也可以得到一个相同的网络号，这个网络号是192.168.0.64，这表明右边这两个主机也在一个同样的网络上，这个网络就是192.168.0.64，这样左边和右边他们就不在同一个网络，

　　我们来验证一下是不是这样的情况。我们先用左下面这台主机去Ping一下上面这台主机，PING 192.168.0.1，我们可以看到可以Ping通，这是因为他们在同一个子网当中，我们再用下面这台主机去Ping一下右上角的主机192.168.0.65。PING192.168.0.65 第一次请求超时，第二次请求超时，第三次也超时了了，第4次也超时了。

　　同理我们用现在左下角这台主机去Ping一下右下角这台主机，因为他们不在同一个子网里面，应该也是Ping不通的。现在我们用右边的上面这台主机，也就是我们用右侧上方的这台主机，我们用它来Ping一下，和它属于同一个子网的下面这台主机应该是能够Ping通的，我们看一看是不是这样子。192.168.0.66，我们可以看到收到4个响应，这是Ping得通的，这样就证明了我们刚才的分析，也就是说左边两个主机是同一个子网，它们之间可以通信，右边两个主机是同一个子网，它们两个可以加相互通信，但是左右两边他们不能通信，为了使左右两个网络能够相互通信，我们就需要用到第三层的网络互联设备，也就是路由器。

　　![](https://image.peterjxl.com/blog/image-20220102113425-hr3divb.png)

　　‍

---

　　‍

　　我们拖动一台普通的路由器到逻辑工作空间，然后将之前两个交换机之间的连线给它们断开，我们选择这里的删除。然后把鼠标状态切换回选择状态，然后我们在这里选择自动连接类型，将两个交换机分别连接到这个路由器上，我们可以看到此时路由器的接口以及交换机的接口都是红色指示灯，这是由于路由器的这两个端口还没打开，我们先将它们打开，然后再选择它的端口1把它打开。这个时候这儿就变成了绿色指示灯，但是这样还是橙色的，我们切换几下实时和仿真按钮，这个状态指示灯全部变成了绿色，现在需要为路由器的端口0和端口1各设置一个IP地址和子网掩码。

　　![](https://image.peterjxl.com/blog/image-20220102113910-63m9exf.png)

　　由于端口0与它左边的这两台主机属于同一个网络，因此它们应该有相同的子网掩码以及相同的网络号，只有主机号部分是不同的。同理，路由器的端口1和它右侧的这两台主机，它们是同一个网络里面的，所以他们的子网掩码应该相等，并且网络号也应该相等，而主机号应该不相等。我们在理论课程中曾经介绍过分类网快速划分子网的方法，现在我们在这里再次的使用一下这种方法，我们通过子网掩码，最后的10进制数192我们就可以看到第4次增长的增量，也就是第4个10进制数的增量应该用256-192=64，这样的话我们就可以立刻得出子网地址，因为这是一个C类网化分子网，所以它前三个字节的都是不动的，也就是192.168.0就是固定不动的，那么它从0开始增长，每次增长步长为64，也就是增量为64，那么第一个子网是192.168.0.0。第二个也就是在它基础上增加64，那么也就是192.168.0.64，以此类推，一直到这个增长到192。这样我们就把通过子网掩码，我们可以看出来就画成了4个子网，每一列就是1个子网。那么这是每个子网的子网号，那么在每个子网里面最小可分配给主机的 IP地址是比它子网号，也就是比子网地址大一的地址。那么第一个值也就是192.168.0.0，这个值往上的最小可分配给主机的 IP地址就是192.168.0.1，那它的第一个子网的广播地址应该比它后面子网小一，后面子网的网络地址是192.168.0.64，因此第一个子网它的广播地址就是192.168.0.63，另外在子网上面最大的主机，它的地址应该比它的广播地址再小一，所以应该就是192.168.0.62。

　　后面的大家可以依次按这个规律去分析出来，这就是一个使用这样的一个子网掩码，对C网192.168.0这样的一个C类网进行划分子网的具体的细节。我们在这里看到我们左侧的两个主机，其实他们根据他们的IP地址，我们在这儿可以找到，他们是被划分到192.168.0.0子网里面去了，并且上面主机它的IP地址是最小可分配的 IP，也就是192.168.0.1，而下面的这个是他随后紧接着他后面的那个地址就是0.2，那么我们现在就可以给路由器它的接口分配一个IP地址，假如说我们就分配，因为它现在也属于子网192.168.0.0上面，所以我们给他分配一个其实是可以随意分的，1、2这两个不能分，一直到62，那么我们就取62这个值分给他。那就是192.168.0.62，那子网掩码这里它会默认给你一个，但是实际上我们现在的子网掩码是3个25，然后192，所以把这里改为192。

　　![](https://image.peterjxl.com/blog/image-20220102113719-ilhacgk.png)

　　同理我们可以看到右边这两个主机，其实我们是把它划归在了第二个子网上，也就是192.168.0.64这个子网上，而右上角的主机刚好我们用的是子网上的最小的可分配给主机的IP地址，然后下面这台是紧随其后就66，那么同理我们需要给路由器的端口1的分配，一个在192.168.0.64这个子网上的一个可用的IP，那么这里面我们选用最大的 IP，也就是192.168.0.126，那么它会自动给你一个子网掩码、这次他给的是对的，好我们就无需修改了，

　　‍

　　![](https://image.peterjxl.com/blog/image-20220102113729-l5uzqm2.png)

　　最后不要忘记了，给每一台主机都要设置一个默认网关，那么左边这两台主机给它设置默认网关，其实它们的默认网关就是路由器，右边这两个主机的默认网关也是路由器，只不过作为左边这两台主机，应该给他指定的默认网关的IP地址是路由器的端口0的 IP，而右边这两台主机的默认网关，它的 IP地址应该设置路由器的端口1的IP。那么我们就来设置一下，我们刚才说了路由器的端口0，它的 IP地址是192.168.0.62，也就是子网0上的192.168.0.0，子网上面的最大的IP地址，就是这样的，192.168.0.62，好我们把它复制一下，这样的话下面这台主机他的默认网关也是这个地址。

　　那么我们再来给右边两台主机设置一下默认网关，那么我们刚才说了右面这两台主机，包括路由器的端口1，它们都属于子网192.168.0.64这个子网上的，那么并且我们刚才给端口1分配了子网192.168.0.64，上面的最大主机IP地址也就126，192.168.0.126，所以我们这里面要给这两台主机指定的一个默认网关，就是这个IP地址，192.168.0.126，我们复制一下，下面这个主机也同样的这样给它配置上。那么按道理来说，现在这4台主机可以左右相互通信了，之前没有路由器的时候，如果配置这样的子网掩码只能左侧两个之间通信，右侧两个之间通信，左右不能通。现在我们相当于用路由器把左右两个网络给它互联起来了，并且左右的这些主机都分别设置了默认的网关。他们现在应该可以通信了，我们来验证一下，我们用左边这台主机来Ping一下，先Ping在下面，就是没有这个路由器存在，按道理也应该Ping得通，我们来看一下 PING然后192.168.0.2，确实可以Ping通，那么我们现在再用左上方主机来Ping一下它右侧的192.168.0.65的这台主机，我们看一下能不能Ping操。我们现在开始Ping第一次请求超时了，第2次就Ping通了，然后第3次第4次都是Ping通的，那说明他们是可以通信的。为什么第一次存在这样的一个超时，这里面有多次使用ARP广播请求的这样的一个过程在里面，所以第一次是会超时的，之后的话就不会再发动这个ARP广播请求了，因此Ping应用程序就不会觉得超时了。这样的话我们就验证了左上方的和右边的右上方的可以通自然和它下面这个也能通，

```js
C:\>ping 192.168.0.66

Pinging 192.168.0.66 with 32 bytes of data:

Request timed out.
Reply from 192.168.0.66: bytes=32 time<1ms TTL=127
Reply from 192.168.0.66: bytes=32 time=5ms TTL=127
Reply from 192.168.0.66: bytes=32 time<1ms TTL=127

Ping statistics for 192.168.0.66:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 5ms, Average = 1ms
```

　　我们来试一下。66，那么仍然可以看到第一次Ping的时候会有一个超时，就是我们刚才说的ARP的事情。之后连续3次都是没有超时的通了，那么我们现在再重新Ping一次，他应该很快的这4次的都不会超时。

　　本次实验就进行到这里。下面给您布置一个练习，我们将左边这两台主机以及路由器的端口0划归到这个网上面，也就是192.168.0.128，将右边这两台主机和路由器的端口1给它划归到这样的一个子网上面，也就是192.168.0.192这个子网上，请您给这4个主机以及路由器的2个端口重新分配IP地址，以及设置子网掩码，那么目的是使得他们之间这4个主机之间可以相互通信，请您特别需要注意的时候，配置完了以后，不要忘记给每个主机指定他的默认网关

　　‍

　　‍

# 构造超网（无分类编址）

　　‍

　　‍

　　下面我们来进行一个仿真实验，本仿真实验的目的在于帮助大家加深对IP地址第三个历史阶段，也就是构造超网的理解  
构造超网也称为路由聚合。它使用无分类编制的方法，

　　首先我们介绍一下本仿真实验的具体内容，构造如图所示的网络拓扑，网络中包含4个网络，假设给每个网络分配1个地址块，请根据各网络所分配的地址块完成以下工作，以便实现各主机间的相互通信。

　　第一给各主机分配一个IP地址，并设置子网掩码。  
第二给各路由器的各接口分配一个IP地址，并设置子网掩码。  
第三，给各主机指定默认网关，也就是默认路由器。  
第四给各路由器配置静态路由，并且进行进一步的路由聚合。

　　我们先对题目进行分析，我们需要写出各网络所分配地址块的详细信息，这在理论课中已经详细介绍过了。先看192.168.16.0/25这个地址的话，根据斜线后面的数字25可知网络前缀为25个比特，  
因此将前25比特固定不变，而剩余7比特全部清零，这就是该地址块的最小地址，写成点分十进制形式为192.168.16.0，地址块的最小地址也作为网络地址，  
将前25比特固定不变，而剩余7比特全部之一，这就是该地址块的最大地址，写成点分10进制的形式为192.168.16.127，地址块的最大地址也作为广播地址，由于网络地址和广播地址都不能分配给主机或路由器，因此，可分配给主机或路由器的地址范围为192.168.16.1到192.168.16.126。根据斜线后面的数字25可知地址掩码有25个，连续的比特1，剩余7个连续的比特0。写成点分10进制形式，为255.255.255.128。

　　再来看192.168.16.128/26这个地址框，根据斜线后面的数字，26可知网络前缀为26个比特，因此将前26比特固定不变，而剩余6比特全部清零，这就是该地址块的最小地址，写成点分十进制这个形式为192.168.16.128。地址块的最小地址也作为网络地址

　　将前26比特固定不变，而剩余6比特全部置一，这就是该地址块的最大地址，写成点分10进制的形式为192.168.16.191，地址块的最大地址也作为广播地址，由于网络地址和广播地址都不能分配给主机或路由器，因此可分配给主机或路由器的地址范围为192.168.16.129~192.168.16.190。  
根据斜线后面的数字26可知地址掩码有26个连续的比特一，剩余6个连续的比特0，写成点分十进制形式为255.255.255.192，相信大家可以很快的写出另外两个地址块的详细信息。

　　‍

　　‍

　　‍

---

　　现在我们已经得出了各网络的地址掩码以及可分配IP地址的范围，我们先给上面网络分配，该网络中有两个主机和一个路由器接口，他们的地址掩码都为255.255.255.128，我们可以从192.168.16.1\~192.168.16.126，这个地址范围中，为各主机及路由器接口分配IP地址，例如我们给网络中的这台主机分配的IP地址为192.168.16.1，给另一台主机分配的IP地址为192.168.16.2，可将分配地址范围中的最后一个地址也就是192.168.16.126，分配给路由器接口。当然你也可以自行分配，只要在可分配地址范围内选择地址就可以了。

　　再来给下面网络分配。该网络中有两个主机和一个路由器接口，他们的地址掩码都为255.255.255.192，可从192.168.16.129\~192.168.16.190，这个地址范围中为各主机及路由器接口分配IP地址，例如我们给网络中的这台主机分配的IP地址192.168.16.129，给另一台主机分配的IP地址为192.168.16.130，将可分配地址范围中的最后一个地址，也就是192.168.16.190分配给路由器接口。

　　接下来我们给两个路由器之间的这道链路，也可以看作是一个网络进行分配，该网络中仅有两个路由器接口，他们的地址掩码都为255.255255.252，该网络可分配的IP地址只有192.168.16.193和192.168.16.194，因此给该网络中的两个路由器接口各配置其中一个IP地址即可。

　　最后我们给最右侧的网络分配，该网络中有一个主机和一个路由器接口，他们的地址掩码都为255.255.255.252，该网络可分配的IP地址只有192.168.16.197和192.168.16.198。因此，对该网络中的主机和路由器接口各配置其中一个IP地址即可。

　　![](https://image.peterjxl.com/blog/image-20220102154033-a7xmhke.png)

　　‍

---

　　现在请您思考一下，同一网络中的各主机之间，主机与路由器接口之间，各路由器接口之间是否可以直接通信？答案是可以通信。再来思考一下上面网络中的某个主机和下面网络中的某个主机，它们之间是否可以直接通信？答案是不可以通信，这是因为他们处于不同的网络，他们都需要将数据包发送给各自网络上的默认路由器，由默认路由器帮他们进行转发默认路由器要称为默认网关。左边的这台路由器既是上面网络的默认网关，也是下面网络的默认网关。  
对于上面网络中的各主机，我们为其指定的默认网关的地址，是左侧路由器上面这个接口的IP地址，也就是192.168.16.126，对于下面这个网络中的各个主机，我们为其指定的默认网关的地址是左侧路由器下面这个接口的IP地址，也就是192.168.16.190，对上下两个网络中的各主机指定了默认网关后，他们之间就可以相互通信了

　　不要忘记，还有最右侧这个网络中的主机也应该为他指定默认网关，右侧路由器就是它的默认网关，我们为他指定的默认网关的地址是右侧路由器，右边这个接口的IP地址，也就是192.168.16.197，请再想想看上面网络中的某个主机或下面网络中的某个主机是否可以与最右侧的主机进行通信，答案是不可以通信。这是因为图中的两个路由器并未使能路由选择协议，也就是并不使用路由算法，他们仅知道与他们直接相连的有哪些网络

　　路由器可以根据自己的各接口所分配的IP地址和地址掩码，知道自己都与哪些网络直接相连。

　　例如左侧的这台路由器，他知道自己的上面这个接口与网络192.168.16.0/25直接相连，

　　自己的下面这个接口与网络192.168.16.128/26直接相连，自己的右侧这个接口与网络192.168.16.192斜线30直接相连，但他并不知道右侧的网络192.168.16.196/30如何到达，甚至可以说他并不知道网络的存在，这就需要我们对它进行配置，告诉他如果数据包要到达网络，192.168.16.196/30，可以将数据包转发给右侧这个路由器，也就是指定下一条地址为右侧路由器的左边接口的地址，也就是192.168.16.194。

　　同样的道理，相信您可以很快得出右侧这台路由器的路由表，对于直接相连的网络，路由器可以自行得出，而最后两行所示的非直接相连的网络及下一跳地址需要我们进行配置，这次各主机间就完全可以通信了。

　　‍

　　![](https://image.peterjxl.com/blog/image-20220102154415-juv92o4.png)

　　‍

　　最后请您再思考一下，右侧路由器的路由表中的最后两条路由是否可以聚合为一条路由，以便减少路由表中的路由记录数量，这样就可以减少对存储器空间的占用，并且可以提高查找路由表的速度。我们在理论课中已经介绍过，采用找出共同前缀的方法来进行路由聚合，这里就不再赘述了。最终聚合的地址块为192.168.16.0/24。

　　‍

---

　　我已经在软件中构建好了我们之前所讲解的网络拓扑，那么这里我们可以看到交换机的各个接口指示灯是橙色的，那么下面交换机也是。那么我们切换一下右下角的实时和仿真按钮，直到它们变为绿色。但是我们现在看到路由器的各个接口仍然是红色，这是因为我们现在的路由器的各个接口仍然处于关闭状态，等一下我们再给路由器各接口配置IP地址的时候，顺便把它打开就可以了。

　　另外路由器需要大家注意一下，我在这里选择的路由器是2911这个型号，如果不选这个的话，可能它的接口是不够用的。为了我们稍后对各主机和路由器进行配置的方便，我已经将我们之前所分析的结果都标注在了各个主机以及路由器各接口的旁边。

　　![](https://image.peterjxl.com/blog/image-20220102172732-gjy41kj.png)

---

　　‍

　　下面我首先给主机设置IP地址和子网掩码，注意一下，我们先不指定各主机的默认网关。我给左边最上面的左上角的这台主机设置IP地址，左键点击它，然后选择桌面，然后这里有IP配置，给他的IP地址就是这里的192.168.16.1，那子网掩码是三个255一个128，当我们点击的时候，它会自动给一个C类的默认的子网掩码，我们修改一下，把最后0改成128

　　![](https://image.peterjxl.com/blog/image-20220102172026-iennaxx.png)

　　请您依次给各个主机按照我们之前的方法去配置IP地址和子网掩码这里我就不再详细演示了。下面我们来给路由器的各个接口配置IP地址和地址掩码。

　　‍

　　‍

　　‍

---

> 这里需要注意一下，由于本身我们给各个主机和路由器标注了很多内容，所以我将这个软件它本身默认显示的端口或者是接口号以及设备的型号，比如说路由器的型号，主机的型号以及它们的名称，它本来是默认显示的，我都把它关闭了。那么在这里在菜单栏选择选项，然后参数选择，我们可以看到我把这个显示设备型号设备名称以及在空间中逻辑工作空间中显示端口标签这些内容我都把它选掉了，
>
> 但是我把这一项点开了，也就是当鼠标在逻辑空间中的设备上悬停时，会显示端口标签，这个是很重要的。因为我们现在要给路由器的各个端口去配置IP地址，那么我们可以看一下，当我打开以后，这儿点击配置以后，我可以看到它有这么多的接口，有012有三个接口，但是这012分别是对应的上右下的这三个是哪一个具体对应，那么我们现在还不知道，所以当我把鼠标放到接口的指示灯上，我们就可以看到这是0号接口，那放到这儿我们可以看到这是2号接口，放在下面我们可以看到这是一号接口，这样我们就可以对路由器的各个接口进行IP地址和地址掩码的配置了。

　　‍

　　那么我们先来配置左边路由器，我们鼠标左键把它点开，然后在配置选项卡里面我们进行配置。那么我们首先来配上面这个端口，这个端口刚才我们的已经知道它是0号端口，所以我们选择这儿0号端口。首先上来我们可以把它这个地方的端口状态或者叫接口状态给它点开，所以我们可以看到这个时候路由器下面的接口指示灯变成绿色了。然后IP地址就是我们之前分析的 IP地址，也就是192.168.16.126，然后子网掩码我们给它设置成它会默认给你一个，但是我们所要求的是三个255，一个128，所以把这改掉，128。然后我们回车一下，另外需要说明的是这里我们为了方便没有去进入到命令行的模式，我们刚才这个动作设置IP地址和子网掩码，其实相应的也可以用命令行命令的方式，就是这一条IP address，然后给 IP地址和后面的子网掩码。这样端口0的IP我们就设好了。

　　![](https://image.peterjxl.com/blog/image-20220102172254-zaqskpr.png)

　　下面我们设下面这个端口的下面这个端口，刚才我们看到应该是端口1的，首先我们也是把它打开，然后 IP地址是我们在这已经标出来了，192.168.16.190、那子网掩码他会给一个3个255，1个128，这个和我们所需要的这儿需要配置的是3个255，1个192这个端口接口我们也配置完了，

　　![](https://image.peterjxl.com/blog/image-20220102172441-3xn5374.png)

　　那么最后在路由器的右侧的接口，也就是2号接口，那么首先我们把它打开，然后这个接口我们看这儿写的是IP地址192.168.16.193，子网掩码的话，我们这儿是三个255，一个252，那么把它自动生成的改成252，好回车，这样路由器我们就配置完了，也就是它的各个端口的各个接口的IP地址和指导员我们已经设置完了。

　　![](https://image.peterjxl.com/blog/image-20220102172518-kvlmh3v.png)

　　请您按照之前我们介绍的方法，将路由器的这两个接口配置IP地址和子网掩码，我们这里就不具体的去演示了。

　　‍

　　‍

---

---

　　‍

　　那么到这里我们已经给各个主机配置了IP地址和子网掩码，以及给各个路由器的各个接口的配置了IP地址和地址掩码。那么下面我们就来看一看，按道理讲上面这两台主机之间应该可以通信，下面这两台主机之间应该可以通信，我们来验证一下是不是这样子的。

　　我们用上面的左边这台主机把它点开，然后选择命令提示符，然后我们去Ping一下，我们用左边主机去Ping右边主机的IP地址 Ping 192.168.16.2。我们看到有4个响应，也就是从我们Ping的 IP地址收到了4条响应证明这是通的。  

```js
C:\>ping 192.168.16.2

Pinging 192.168.16.2 with 32 bytes of data:

Reply from 192.168.16.2: bytes=32 time<1ms TTL=128
Reply from 192.168.16.2: bytes=32 time=6ms TTL=128
Reply from 192.168.16.2: bytes=32 time<1ms TTL=128
Reply from 192.168.16.2: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.16.2:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 6ms, Average = 1ms
```

　　那么再用下面左侧的主机去Ping右侧的主机。我们来看一下 Ping空格，192.168.16.130，好。也是从我们所Ping的 IP地址收到了4条响应，这代表了也是通的。

```js
C:\>ping 192.168.16.130

Pinging 192.168.16.130 with 32 bytes of data:

Reply from 192.168.16.130: bytes=32 time<1ms TTL=128
Reply from 192.168.16.130: bytes=32 time<1ms TTL=128
Reply from 192.168.16.130: bytes=32 time<1ms TTL=128
Reply from 192.168.16.130: bytes=32 time<1ms TTL=128

Ping statistics for 192.168.16.130:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　‍

　　那么想想看上面网络中的主机和下面网络中的主机，他们之间不通，应该是不通的，我们来验证一下，我们用上面这个主机，我们用上面这个主机来Ping一下下面这个主机， Ping192.168.16.129。正在进行Ping的过程，会发4个请求过去第一个请求超时了，没有受到响应，第二个所发生的请求也没有收到，对方回答的响应也是超时了。第三个同理，4个请求都没有收到相应的响应，这个就表明上面和下面是不通的。

```js
C:\>ping 192.168.16.129

Pinging 192.168.16.129 with 32 bytes of data:

Request timed out.
Request timed out.
Request timed out.
Request timed out.

Ping statistics for 192.168.16.129:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

　　‍

---

　　‍

　　其实我们之前已经介绍过了，这是因为我们给主机和下面这些主机都没有指定默认网关，下面这个主机要把数据包发给下面这个主机，它首先就会判断下面主机和自己不在同一个网络，所以下面这个主机首先就要把数据包的发送给默认网关，由默认网关的帮他转发，但是由于我们之前没有给它设置默认网关，所以就会导致它其实不知道把数据包该怎么发送了，那么现在我们就给他**指定默认网关**，这样从图上可以看出来主机的默认网关或者说默认路由器就是最左侧的路由器，那么我们将路由器的端口也就是和这台主机在同一个网络中的端口告诉主机，那么我们点开它，然后点IP配置，这里面的话在这儿默认网关，把它默认的4个0给它去掉，那么我们改为这个地方的192.168.16.126

　　![](https://image.peterjxl.com/blog/image-20220102173012-ozu6d9z.png)

　　‍

　　同理，我们给下面主机也指定一个默认网关，它的默认网关其实也是这台路由器，只不过是接下路由器下面这个接口和它处于同一个网里，所以我们就应该把下面这个接口作为它的默认网关的地址。我们点IP配置把原来默认的4个0给它修改为默认网关的这个地址，也就是接口的地址。这个接口是192.168.16.190。我们给上面这台主机已经指定了默认网关是路由器的接口，给下面这个主机也指定了它的默认路由器是这个路由器，当然我们指定的是下面接口的IP地址

　　![](https://image.peterjxl.com/blog/image-20220102173040-oktzeun.png)

　　‍

　　‍

　　现在的话理论上来讲，上面和下面这两台主机之间应该是可以通信了，那么我们来看一下是不是这样子的。我们现在就用上面这个主机来Ping一下下面这个主机，ping空格，然后192.168.16.129回车。那么第一次请求超时了，第2次请求回来了，第3次请求也有响应回来了，第4次请求也有响应回来了。

```js
C:\>ping 192.168.16.129

Pinging 192.168.16.129 with 32 bytes of data:

Request timed out.
Reply from 192.168.16.129: bytes=32 time<1ms TTL=127
Reply from 192.168.16.129: bytes=32 time<1ms TTL=127
Reply from 192.168.16.129: bytes=32 time<1ms TTL=127

Ping statistics for 192.168.16.129:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　证明上面这台主机和下面这台主机现在已经可以通信了，那么为什么第一次的Ping的请求会超时，是因为第一次存在这样一个问题，我们这台主机首先他要判断他所发送的数据包的目的地址，也就是这台主机的目的地址，和他自己不在一个网络，所以他就应该把数据包交给他所在网络的默认路由器，换句话说他要把数据包发给 Ip地址，于是他就在他自己的高速缓存里面去ARP的高速缓存里面去查找，但是他找不到这个IP地址对应的MAC地址。所以他首先发了一个ARP的广播请求，路由器在收到广播请求以后发现问的是自己的接口的 MAC地址，路由器就会给这个主机发一个ARP的单播响应，把自己的MAC地址告诉他。

　　同理当路由器要把数据包转发出来给主机的时候，路由器也在自己的ARP高速缓存去查这台主机的IP地址对应的 MAC地址，刚开始也是没有的，会发一个ARP广播请求，主机收到以后给路由器一个ARP单播响应，之后路由器才能把数据包重新封装出来发给这台主机。所以这样的一个过程就造成了我们的听的应用程序的超时。但是一旦第一次这个过程完成以后，那么第二次就不存在这一段这一个网络中的ARP的广播请求和响应，也不存在这一段网络中的ARP广播请求和响应，数据包就是从主机发出来，那么通过交换机在到达路由器查表，立刻就转发到交换机，又转发到这台，主要这样就不会超时了。

---

　　那么请您按照我们各个主机旁边所标注的默认网关，给其他剩余的这三台主机都配置默认网关，那么我这里就不再详细演示了。我已经将剩余的这三个主机的默认网关也配置好了。下面想一想下面网络中的任何一个主机或者下面网络中的任何一个主机，能不能和最右侧网络中的这台主机进行通信？理论上是不行的，我们实际来验证一下，看是不是这样。那么我们假如用左上方这台主机来Ping一下最右侧的这台主机，它的地址是我们Ping一下，就是主机的 Ip地址192.168.16.198。

```js
C:\>ping 192.168.16.198

Pinging 192.168.16.198 with 32 bytes of data:

Reply from 192.168.16.126: Destination host unreachable.
Reply from 192.168.16.126: Destination host unreachable.
Reply from 192.168.16.126: Destination host unreachable.
Reply from 192.168.16.126: Destination host unreachable.

Ping statistics for 192.168.16.198:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

　　我们会得到这样一条消息，这个消息的话我们可以看到响应来自于哪里？来自于192.168.16.126。那来我们是上面主机给下面主机发请求报文，但是我收到了响应是来自于 Ip地址的，这个IP地址我们看一下在这里面就是路由器的接口，说白了就是当主机给主机发送数据包的时候，数据包先到了路由器，而这个路由器会向我主机进行一个报告的什么呢？目的主机不可达。换句话说，之前上面主机要发给右侧主机的数据包，首先到达了路由器下面就要把它进行转发，但是路由器不知道如何转发，所以路由器没法转发它就不转发了。同时他会把这个事情再告诉这台主机，也就给主机发一个数据包，告诉他你刚才发给我的数据包我没有办法，我不知道如何把它转发出去。

　　路由器是根据自己的路由表，然后对接收到的数据包进行转发的。那么我们说之前我们刚才也看了，路由器收到了主机发来的数据包，但是路由器不知道怎么去转发，来不知道怎么去转发到这台主机，我们看一看是不是这样子的。我们再点击查看，然后查看一下路由器的路由表，那么我们可以看到在路由表里面，192.168.16.0/25实际上指的是上面网络，192.168.16.128指的是下面网络，这里还有一个192.168.16.192.30指的是网络，也就是路由器它直接相连的这三个网络他自己是知道的。

　　![](https://image.peterjxl.com/blog/image-20220102173417-vevik5z.png)

　　‍

　　‍

　　另外我们在这里面还可以看到斜线32的有三条记录，实际上是分别记录了他自己的这三个接口的IP地址。那么这个路由器和它自己直接相连的三个网络他是知道的，但是我们刚才是主机要把数据包发给主机，也就数据包要到达网络，而这个网络的话对于路由器左边的路由器来说，它根本就不知道，我们可以说它甚至不知道网络的存在，所以需要我们手工指定给他。

　　那么我们之前就已经分析过了，那么我们需要给他指定到这个网络，也就告诉他有这样的一个网络，所以说有这样一个目的网络192.168.16.196，然后相应的地址掩码是三个255，一个252，并且告诉他要到达网络去的话下一跳，应该跳给他右侧的路由器的接口，也就是跳给IP地址为192.168.16.194的这个接口，我们在这儿也标出都标出来了接口。那么下面我们就对这个路由器，我们给它添加一条静态路由，那么我们先把鼠标状态切回到选择状态，然后点击这个路由器，那么在这个里面配置选项卡里面，我们可以看到在路由下面有一个静态，那么在这里面就可以添加静态路由，那么我们就把这一条添进来，网络是192.168.16.196，那掩码255.255.255.252，那下一跳地址是192.168.16.194，然后点击添加，我们就可以看到我们告诉他的一条，要到达网络去，要通过这个地址也就下一跳要转发给这个IP地址。

　　![](https://image.peterjxl.com/blog/image-20220102173734-0v5aw95.png)

　　那么我们再点击右侧查看按钮，我们在打开路由器的路由表看一下，那么我们可以看到这一条 s就代表静态的，也就是我们刚才添加的那一条路由，也就是到达网络去下一跳，我应该跳给这样的一个IP地址。

　　![](https://image.peterjxl.com/blog/image-20220102173751-j2hplhx.png)

　　那么请您按照我们给这一台路由器配置静态路由的方法，给这一台路由器添加两条静态路由，一个是到目的网络这个目的网络去的，另一个是到目的网络这个目的网络去。注意，先不要管下面路由聚合的事情，就给路由器添加这样两条。需要说明的是上面这一条静态路由，其实是告诉路由器如何到达上面网络，也就是说它的下一跳应该跳给这个接口。

　　那同理，下面这一条静态路由实际上是告诉我，路由器如何到达下面网络，那么他也是应该通过这接口，那也就是下一条地址应该跳给他，最终才能到达下面网络。

　　![](https://image.peterjxl.com/blog/image-20220102173853-kyse32n.png)

　　现在的话我们把鼠标状态切换回选择状态，然后我来给路由器添加这两条静态路由，点开它以后，选择静态，我们先添加第一条就是192.168.16.0，这是网络，那么它的相应的地址掩码是三个255，然后128。下一跳地址是192.168.16.193，然后我们点击添加。

　　接着我们再来把下面这一条静态路由也配置进去，下面这一条是16.128，把这改成128，然后掩码这是192，把这儿改成192，下一跳，不变，下一跳，仍然是刚才我们说的路由器的右侧接口，好大家再点添加，这样的话我们就给路由器配置了两条静态路由，现在理论上讲整个拓扑结构中的这5台主机，它们相互之间都是可以通信的。

---

　　‍

　　那么我们来验证一下比较关键的就是上面主机和右侧这个主机或者下面这个主机和右侧主机他们是否能够通信了？那么我们就用右上方的主机，我们来Ping一下最右侧的主机，那也就是Ping 192.168.16.198，然后我们来看一下，我们可以看到在经过两次的超时以后，我们从所Ping的目的IP地址收到了响应，那么这里面超时的原因也是我们之前就分析过的，存在于在各个网络上进行ARP的广播发送和单播响应的回送。我们下面再重新Ping一次的话，按键盘的上键可以不用再重复输入命令，然后回车。我们就可以发现上方的主机Ping右边的主机就没有超时了，完全可以Ping得通的。

```js
C:\>ping 192.168.16.198

Pinging 192.168.16.198 with 32 bytes of data:

Request timed out.
Request timed out.
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.198:
    Packets: Sent = 4, Received = 2, Lost = 2 (50% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

```

　　‍

　　那同理我们再用右侧主机Ping一下下面这个网络中的某个主机，我们点开它，然后选择命令行，比方说我们去Ping这台主机，那就是ding空格192.168.16.130。我们可以看到直接就从这个目的IP地址连续收到了4个响应，我们听了他发了4个请求那，一次回来4个响应，这里没有发生第一次超时的问题，这是因为我们刚才用上面这台主机在Ping下面这台主机的过程中，这个网段已经用了ARP这个网段上也用了ARP这个网段上用了，那么我们之后用这台主机去Ping这台主机的话，实际上这个网段和这个网段都没有用，ARPP只存在于这一个网段，但是 ARP所造成的时间的消耗，它在我们Ping的响应回来的超时时间之内，所以就不会产生超时。  
总之我们看到用右侧的主机，Ping下面这个主机是也可以Ping得通的。

```js
C:\>ping 192.168.16.1

Pinging 192.168.16.1 with 32 bytes of data:

Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

---

　　最后我们来看一下有关**路由聚合**的事情，我们之前给路由器配置了两条静态路由，一条是路由，这个是告诉我路由器上面网络如何到达的，还有一条是下面这一条静态路由，也就是告诉路由器下面这个网络如何到达。那么其实这两个网络我们对于路径这条路路由器来说的话，我们可以看它下一跳，都是相同的，都是接口。从图上我们也可以很容易看出来，这个路由器的数据包要转发到上面或者下面，其实它都应该把这个数据包转发给路由器。所以我们现在可以把这两条的路由给它合并成一条路由。

　　我们之前在理论讲解中也说过如何去合并静态路由，也就是找这两个目的网络的共同前缀，找到以后就把他们共同前缀，我们发现最后我们得出来是24位，最后合并的路由的就是192.168.16.0/24，相应的由于这个是24的话，它的地址掩码就24个1，然后剩余8个0写成10进制，255.255.255.0，他们的下一跳是不变的，其实路由聚合相当于把上面网络所占用的地址块和下面网络所占用的地址块，给它合并成为一个更大的地址块，而数据包反而是要到达上面这个地块和到达下面这个地块的，都要通过路由器也相当于到达更大的地址块，也是通过这一个路由器的，所以我们可以把它们这两个网络地址块给它合并成这一个。下面的话我们就来把之前的这两条给它合并成一个我们点掉的静态，我们看到这个是我们之前我们添加的

　　![](https://image.peterjxl.com/blog/image-20220102174057-0g6sykw.png)

　　那么先验证一下，我们把它都删除掉，删除掉以后，那么我们主机和这个主机右边主机就应该Ping不通上面主机，我们来看一下， Ping 192.168.16.2，我们看一下这一条消息，我们注意一下是说从这个IP地址192.168.16.197得到了一条响应，响应的内容是目的主机不可达，也就是什么意思？我们主机在Ping主机的过程中，数据包它肯定先要交给它的默认网关，而默认网关现在由于它的路由表，刚才这两条静态路由被我们删了，所以他并不知道如何到达网络去，所以他就要把这个事情告诉我们这台主机，我们可以看到它是通过接口来通知我们这台主机的，而这个接口的IP地址就是192.168.16.197，也就是我们大家看到的，他从这个接口给我们发送的目的主机不可达的消息。那么现在我们就把刚才删除的这两条合并为这一条，我们再给他配置一条，然后聚合以后的路由。

　　我们来看一下这个是192.168.16.0、然后掩码是255.255.255.0。下一跳地址就是这个路由器是这边路由器的接口，好就我们标注的也就是这个地方的 IP地址，192.168.16.193，然后我们添加。这样的话路由器有一条聚合的路由，就是把到达网络和到达网络的这两条路由距合为一条路由，说白了到达更大的地址块，还是要路由器把数据包发给路由器的接口。那么下面我们再用右边的主机Ping一下上面主机 ping 192.168.16.2。现在我们就可以看到了我们这台主机去Ping这个主机，那么我们收到了来自192.168.16.2，也就这台主机的响应发了4个请求，收到4个响应证明是通的。

```js
C:\>ping 192.168.16.1

Pinging 192.168.16.1 with 32 bytes of data:

Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126
Reply from 192.168.16.1: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms
```

　　我们再验证一下，用最右侧主机Ping一下下面这个主机，可能下面这个网络它是否可以到达 Ping 192.168.16.130。我们看到也是依次收到了来自192.168.16.130，也就是这台主机的4次响应，这就证明了路由聚合是成功的。

```js
C:\>ping 192.168.16.198

Pinging 192.168.16.198 with 32 bytes of data:

Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126
Reply from 192.168.16.198: bytes=32 time<1ms TTL=126

Ping statistics for 192.168.16.198:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

```

　　本次仿真实验进行到这里就结束了，该仿真实验它的配置内容比较多，因此您在进行实验的过程当中出错的机会，比如说IP地址配置错误，子网掩码配置错误，或者是默认网关配置错误，又或者是静态路由添加错误，都可能导致您所做的实验现象和我这里所做的实验现象不一致的情况。这时候就请您需要自行去分析到底是因为什么原因产生的，往往就是由于这个地址或者是路由的配置错误产生的
