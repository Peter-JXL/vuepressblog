---
title: 506-控制信号的集成
date: 2023-06-13 14:43:28
permalink: /ComputerOrganization/PekingUniversity/integration-of-control-signals
categories:
  - 计算机基础
  - 计算机组成原理
  - 网课-计算机组成原理（北大-陆俊林）
tags:
  - 
---
# 506-控制信号的集成

　　自己设计出一个处理器是一件非常有意义的工作， 那现在，我们离这个工作的目标只差最后一点点了， 而最后的这一步，又是非常关键的， 那就是把我们之前所产生的这些控制信号集成起来， 并且，让这个处理器能够自动地工作。  
<!-- more -->
　　现在我们已经分析完了这个事例的指令系统中所有的指令， 我们也知道了每一条指令应该设置怎么样的控制信号， 因此，我们现在就已经完成了这5个设计步骤当中的第4步， 接下来我们要做的就是考虑如何集成这些控制信号，形成完整的控制逻辑。

　　![](https://image.peterjxl.com/blog/image-20220920213111-m59txx5.png)​

　　‍

　　那我们先把之前的数据通路中的实现细节隐藏起来，就由一个方框来表示，那控制这个数据通路正常运转的控制信号，一共有这样8个， 那这些控制信号是怎么产生的呢？还是要从来自指令存储器的指令编码开始说起。 之前，我们已经从指令编码当中提取了若干的信号，作为数据通路的输入， 但我们只要回忆一下指令格式就可以知道，还有两个位域，我们没有提及， 这就是opcode和function，而正是这两个位域，是用来表明指令执行什么样的操作。 因此，**我们正是需要用这两个信号，来产生下面这些控制信号**，实现这一部分功能的电路，就被称为控制逻辑， 也就是我们之前提到的控制器。

　　![](https://image.peterjxl.com/blog/image-20220920213207-11uyzx5.png)​

## 以add指令为例

　　要想知道控制逻辑是怎么实现的，我们还是先来看一个例子。 我们以add指令为例，当我们取回一条指令的编码，如果是一条add指令，那它所需要 执行的操作就是这两个，一是将两个寄存器当中的数相加，并保存到另一个寄存器当中， 然后就将PC+4更新到PC寄存器当中。 对于这条指令所需要的各个控制信号的值，我们之前也已经详细分析过。 

　　例如，这个RegDst信号应该为1，而RegWr信号也应该为1， 又比如，这个MemtoReg信号应该为0。

　　![](https://image.peterjxl.com/blog/image-20220920213303-rvnmhbv.png)​

　　‍

　　那我们把这些信号的值都摘出来，汇总成一张表格， 在这张表中，就是执行这条add指令时，各个控制信号的值，而add指令对应的opcode域的值和function域的值，我们也列在上面。那用 同样的方法，我们也可以列出减法指令所对应的所有控制信号的值， 以及其他指令各自对应的控制信号的值。 这样，我们就得到了一张完整的表格，描述了每条指令和每个控制信号之间的关系。 那刚才我们是用一列一列的方式得到了这张表格

　　![](https://image.peterjxl.com/blog/image-20220920213344-9hsm7ej.png)​

　　‍

　　然后我们换一个角度来看，如果按行来看，那我们就可以得到每一个控制信号的逻辑表达式， 我们就以第一行这个RegDst信号为例， 那从这一行可以看出，只有当前指令是加法或者减法指令时， 这个控制信号才需要为1，其他时候都为0，就可以了。 那我们可以把这个控制信号的逻辑表达式写出来， 如果我们有一根信号标明现在是加法指令，即为add， 另有根信号标明现在是减法指令，即为sub， 那这个RegDst的控制信号就等于add和sub这两个信号进行或操作。 

　　那我们还得进一步分析，add和sub这两个信号应该如何生成。 那我们先来看add指令的编码，add指令是一条R型指令， 根据R型指令的位域划分，其opcode域都应该为0，而function域则指明了在R型指令当中，这细分的指令类别。因此，对于I的指令来说， 就是opcode域为全0，而function域的第0位到第4位为0， 第5位为1。这样一种信号的组合就代表了当前指令是add指令， 那我们就可以把add指令的逻辑表达式写出来。 我们先用一根rtype信号，来表示当前是一个R型的 指令，然后我们来看后面的信号，就是function域的第5位， 对于add指令来说，这一位应该为1， 而function的第4位，一直到第0位，都应该为0， 所以我们将function 0到4，每一位都先取非， 然后与function域的第5位，以及这个rtype信号，一起进行与操作， 这样就可以得到了add信号。

　　我们用类似的方法也可以得到sub这个信号。 那么rtype这个信号又是如何产生呢？ 这非常地简单，因为R型指令就是opcode全为0， 所以我们只需要把opcode中的每一位都先取非，然后进行与操作， 那么当opcode全为0时，这个rtype信号就会为1。

　　![](https://image.peterjxl.com/blog/image-20220920213551-22v2879.png)​

　　我们把这些逻辑表达式连起来，就可以得到了RegDst这个控制信号的逻辑表达式， 有了这样的逻辑表达式，我们就可以用与门和非门画出产生这个控制信号的电路图来， 这样，对于这一个控制信号来说，它的控制逻辑就已经是确定的了。 

　　‍

　　‍

　　那我们用同样的方法还可以得到其他控制信号的逻辑表达式， 例如ALUSrc这个信号，我们通过查询刚才的表格，可以知道，它是在 ori指令、load指令和store指令，这三条指令执行时是有效的。 因此我们注意下面，我们只要用类似的方法得到ori、load和store， 这三条指令对应的逻辑表达式，我们就可以得到ALUSrc这个控制信号的逻辑表达式了。 

　　类似地，我们就可以得到所有控制信号的逻辑表达式。 那我们注意到，在下面这个区域，所有的信号都是来自指定的编码了， 而且，在对一些信号进行取非操作之后，这些逻辑表达式全都只有与操作，而上面这个区域的表达式都是在下面这些信号的基础上，进行了或操作，从而产生了最终的控制信号。

　　![](https://image.peterjxl.com/blog/image-20220920213723-fc1awdq.png)​

　　‍

　　因此，我们可以画出这样的一个控制器的示意图。 我们把指令编码中opcode的这六位和function的这六位连出来，先接到一组由与门构成的逻辑电路中。那么这一个逻辑电路就实现了上一页中，下面这片区域的那些表达式，从而产生了一组中间信号， 那么再将这些信号接入一组由或门组成的逻辑电路，这组逻辑电路就实现了上一页中上半部分那些逻辑表达式， 

　　最后又可以得到了我们想要的所有的控制信号。那么这些逻辑电路就是我们刚才所提到的控制逻辑， 这样我们就有了控制器的实现。 在这样的电路实现下，我们固定地将取回指令的最高六位和最低六位，连接到控制逻辑中， 那经过了这些与门和或门之后，就会自动地生成对应的控制信号， 而这些控制信号的值，肯定符合我们刚才对每条指令分析的需求， 这样在指令执行的过程中，就不需要任何智力因素的介入， 去分析当前到底是什么指令，以及需要产生什么样的控制信号， 一切都是通过这样的控制逻辑电路自动生成的， 这样，处理器就能一条接一条地取回指令，自动地执行下去。

　　![](https://image.peterjxl.com/blog/image-20220920213838-7xyhwcf.png)

　　那好，现在我们已经完成了控制信号的集成，并形成了完整的控制逻辑电路， 这最后一步工作，我们也就已经完成了。

　　‍

## 小结

　　现在，我们已经完成了一个处理器结构设计的步骤了， 虽然这个处理器只是单周期的，而且也只支持6条指令， 非常地简单，但是它确实是一个可以使用的处理器了。 如果你有兴趣，还可以继续深入到物理设计的环节，把它真正地制造出来。
