---
title: 3_1_11_段页式管理方式
date: 2023-05-15 16:30:25
permalink: /ComputerOS/cskaoyan/segmentation-paging
categories:
  - 计算机基础
  - 操作系统
  - 操作系统网课-王道考研
tags:
  - 
---
# 3.1_11_段页式管理方式

　　‍各位同学大家好。在这个小节中我们会介绍段页式管理方式，‍‍段页式管理其实是分段和分页这两种管理方式的一个结合，所以这个小节刚开始我们会来分析一下，‍‍分页和分段这两种管理方式最大的优缺点是什么。
<!-- more -->
　　之后我们会介绍分段和分页这两种方式这两种思想的一种结合，从而引出了段页式管理方式。‍‍

　　那之后我们还会介绍在段页式管理当中，‍‍段表和页表与分段分页管理当中的段表页表有什么相同和不同的地方。‍‍

　　最后我们还会介绍怎么实现从逻辑地址到物理地址的变化，我们会按照从上至下的顺序依次讲解。‍‍

　　![](https://image.peterjxl.com/blog/image-20221008215118-tc2j4vo.png)​

　　‍

　　‍

　　‍

## 分页和分段的优缺点

　　首先来看一下分页和分段的优缺点，‍‍在分页管理当中主要考虑的是怎么提高内存空间的利用率，所以采用这种方式的话，内存空间的利用率会很高，‍‍不会产生外部碎片，只会有少量的内部碎片。但是缺点就是‍‍由于分页是按照信息的物理结构来进行划分的，所以我们不太方便按照逻辑模块来实现‍‍对信息的共享和保护，

　　但是对于分段管理来说，分段是按照信息的逻辑结构来进行划分的，‍‍因此采用这种方式的话，就很方便按照逻辑模块实现信息的共享和保护。‍‍不过缺点如果说我们的段很长的话，‍‍就需要为这个段分配很长很大的连续空间，很多时候分配很大的连续空间会不太方便。‍‍

　　另外段式管理是会产生外部碎片的，它产生外部碎片的原理其实和‍‍动态分区分配很类似。

　　![](https://image.peterjxl.com/blog/image-20221008215437-67ncfk5.png)​

　　‍

　　‍

　　‍

　　比如说一个系统的内存本来是空的，那么先后来了三个分段，他们都需要‍‍占用连续的这种存储空间，这个地方有4兆字节的空闲区间

　　![](https://image.peterjxl.com/blog/image-20221008215319-6r6lmod.png)​

　　‍

　　之后第二个分段用完了，于是把它撤离内存。‍‍接下来又来了一个分段占4兆字节，如果它占用了分区的话，这个地方就会产生10兆字节的一个空间。‍‍

　　![](https://image.peterjxl.com/blog/image-20221008215333-2b2imqv.png)​

　　‍

　　接下来如果上面这个段也撤离了，接下来再来了一个分段，也是占14兆字节，‍‍这个地方就会产生六兆字节的空闲的区间

　　![](https://image.peterjxl.com/blog/image-20221008215354-odoosvz.png)​

　　‍

　　再接下来如果还有一个分段到来，它总共需要占20兆字节的这种连续的内存区间，由于此时‍‍这些空闲区间并不连续，所以虽然它们的大小总和是20兆字节，但是这个分段是放不进‍‍内存当中的，因为分段必须连续的存放，‍‍所以很显然段式管理是会产生这些难以利用的外部碎片的。‍‍

　　不过对于外部碎片的解决，其实和咱们之前介绍的那种动态分区分配也一样，可以通过这种紧凑的方式‍‍来创造出更大的一片连续的空间。但是紧凑技术需要付出比较大的时间代价，所以显然这种处理方式‍‍也并不是一个很完美的解决方式。

　　‍

　　‍

## 段页式管理

　　所以基于分页管理和分段管理的这些优缺点，‍‍人们又提出了分段和分页这两种思想的一个结合，于是产生了段页式管理，‍‍段页式管理就具备了分页管理和分段管理的各自的优点。‍‍在采用段页式管理的系统当中，‍‍一个进程会按照逻辑模块进行分段，‍‍之后各个段还会进行分页，比如说每个页面的大小是4KB，那么‍‍0号段本来是7KB，它会被分为4KB和3KB这样两个页面，‍‍对于内存来说内存空间也会被分为大小相等的内存块，或者叫页框，页帧，物理块，‍‍每一个内存块的大小和系统当中页面的大小是一样的，也就是4KB‍‍。最后进程的这些页面会被依次放到内存当中的各个内存块当中。‍‍

　　![](https://image.peterjxl.com/blog/image-20221008215540-otk4nsw.png)​

　　‍

　　‍

　　我们在上个小节学过，如果采用的是分段管理的话，那么逻辑地址结构是由段号和段内地址组成的。‍‍

　　而在段页式管理当中，我们会发现一个进程被分段之后，各个段还会被再次分页，‍‍所以对于段页式管理来说，它的逻辑地址结构应该是由段号、‍‍页号还有页内偏移量组成，这个地方的页号和页内偏移量，‍‍其实就是分段管理当中的段内、地址进行再拆分的一个结果。

　　在考试当中需要注意的是，‍‍段号的位数决定了我们一个进程最多可以分几个段，‍‍而页号的位数决定了每个段最大会有多少页，页内偏移量的位数又决定了页面的大小‍‍和内存块的大小。‍‍

　　所以如果一个系统当中它的地址结构是这样的，‍‍并且这个系统是按字节选址的话，那么段号占16位，所以这个系统当中‍‍每个进程最多可以有2的16次方，也就是64k个段；而页号占4位，所以每个段最多会有2的4次方，也就是16页。‍‍另外页内偏移量占12位，‍‍所以每个页面每个内存块的大小是2的12次方，也就是4KB这么大。‍‍

　　在段页式管理当中，‍‍分段这个过程对用户来说是可见的，‍‍程序员在编程的时候需要显示的给出段号和段内地址这样两个信息，‍‍但是把各个段进行分页的过程对用户来说是不可见的，这只是一个系统的行为，系统会把段内地址‍‍自动的划分为段号和段内偏移量这样两个部分。‍‍所以对于用户来说，他在编程的时候只需要关心段号和段内地址这两个信息，‍‍而剩下的分页是由操作系统完成的，因此段页式管理的地址结构是二维的，‍‍与此相对的段式管理当中地址结构也是二维的，而页视管理当中地址结构是一维的

　　![](https://image.peterjxl.com/blog/image-20221008215911-vup45t2.png)​

　　‍

　　‍

## 段表、页表

　　与之前咱们介绍的分页和分段管理当中的思想相同，‍‍对进程分段再分页之后，我们也需要记录各个段各个页面存放的一个位置，‍‍所以系统会为每个进程建立一个段表。

　　进程当中的各个段会对应段表当中的一个段表项，‍‍而每个段表项由段号，页表长度和页表存放块号组成

　　由于每个物理块的大小是固定的，所以只要知道页表存放的物理块号，‍‍其实就可以知道页表存放的实际的物理地址到底是多少了

　　比如说我们要查找0号段对应的页表，‍‍那么我们知道页表存放在内存为一号块的地方，于是就可以从内存块当中读出0号段对应的页表。‍‍由于0号段长度是7KB，‍‍而每个页面大小是4KB，所以它会被分成两个页面，相应的这两个页面就会依次对应页表当中的一个页表项，‍‍每一个页表项记录了每一个页面存放的内存块号到底是多少。‍‍

　　‍

　　所以通过刚才的讲解大家会发现‍‍在段页式管理当中，段表的结构和段式管理当中的段表是不一样的：

* 段式管理当中的段表记录的是段号，还有段的长度，‍‍还有段的起始地址这么三个信息
* 而段页式管理当中记录的是段号，页表长度，‍‍页表存放块号这么三个信息，‍‍也就是后面的这两个信息不太一样，

　　‍

　　而对于页表来说，段页式管理和分页管理的页表结构‍‍基本上都是相同的，都是记录了页号到物理块号的一个映射关系，‍‍各个段表项的长度是相等的，所以段号可以是隐含的，‍‍各个页表项的长度也是相等的，所以页号也是可以隐含的，这两点咱们在之前的小节有详细的介绍过，这就不再展开。‍‍

　　从这个分析当中我们会发现一个进程只会对应一个段表，但是每个段会对应一个页表，‍‍因此一个进程有可能会对应多个页表‍‍。再重复一遍，一个进程会对应一个段表，但是一个进程有可能会对应多个页表

　　![](https://image.peterjxl.com/blog/image-20221008220205-axpzgqn.png)​

　　‍

　　‍

## 转换过程

　　那么接下来我们再来看一下‍‍怎么实现段页式管理当中的这种逻辑地址转换为物理地址的过程。‍‍首先需要知道的是系统当中‍‍也会有一个段表寄存器这么一个硬件，然后在进程上处理机运行之前，‍‍会从PCB当中读出段表始址，还有段表长度这些信息，然后放到段表寄存器当中。‍‍

　　在进行地址转换的时候，第一步是需要根据逻辑地址得到段号，页号，还有页内偏移量这么三个部分。

　　第二步‍‍需要把段号和段表长度进行一个对比，检查段号是否越界是否合法，‍‍如果越界的话就会抛出一个中断之后由中断处理程序进行处理，如果没有越界的话，就证明段号合法就可以继续执行。‍‍

　　接下来根据段号还要段表始址，来计算出这个段号对应的段表项在内存当中的位置，‍‍这样的话就找到了我们想要找的段表项。‍‍

　　接下来一步需要注意，由于各个段的长度是不一样的，‍‍所以各个段把它们分页之后，可能分为数量不等的不同的一些页面，‍‍比如说有的段长一些它就可以分为两个页面，有的段短一些只需要用一个页面，‍‍所以由于各个段分页之后页面数量可能不同，因此这个地方我们也需要对页号的合法性进行一个检查，看看页号是否已经越界。‍‍如果页号没有超出页表长度的话，那么就可以继续往下执行。‍‍

　　通过段表项我们知道了页表存放的位置，‍‍于是就可以从这个位置读出页表，于是可以根据页号来找到我们想要找的页表项。‍‍找到页表项之后，我们就知道这个页面在内存当中存放的位置，

　　所以最后我们可以根据‍‍页表项当中对应的内存块号和页内偏移量进行‍‍二进制的拼接，最终形成要访问的物理地址。‍‍最终我们就可以根据这个物理地址进行访存访问目标内存单元

　　‍

　　‍

　　因此在段页式管理当中‍‍进行地址转换的过程，总共需要三次访存，第一次访存是访问内存当中的段表，‍‍第二次访存是访问内存当中的页表，第三次访存才是访问最终的目标内存单元

　　我们之前也介绍过在分页和分段这两种管理方式当中，可以用‍‍引入快表机构的方式来减少地址转换过程当中保存的次数。‍‍所以这个地方我们也可以用相同的思路，我们可以引入快表机制，‍‍用段号和页号作为快表的查询的关键字，如果快表命中的话，我们就可以知道我们最终想要访问的页面‍‍到底是在什么位置。因此只要快表命中，我们就不需要再查询段表和页表了。‍‍这样的话我们仅需要一次缓存，也就是最终访问目标内存单元

　　![](https://image.peterjxl.com/blog/image-20221008220554-qtbu54y.png)​

　　那么这就是段页式管理方式当中进行地址变换的一个过程。‍‍需要着重注意的是这一步就是检查页号是否越界，‍‍这个和段式存储当中检查段内地址是否越界是比较类似的，‍‍需要检查的本质原因就在于各个段的长度可能是不相等的，因此需要进行这样一个合法性的检查。‍‍

　　‍

　　‍

　　‍

　　‍

## 小结

　　那么这个小节我们介绍了段页式管理，在学习了之前的分段还有分页管理之后，小节的内容并不难理解，‍‍需要注意的是段页式管理当中逻辑地址结构由段号、页号和页内偏移量这么三个部分构成，‍‍但是用户在编程的时候只需要显示的给出段号和段内地址，‍‍之后会由系统自动的把段内地址拆分为页号和页内偏移量这么两个部分。‍‍因此由于用户只需要提供段号和段内地址这么两个信息，因此‍‍段页式管理当中地址结构是二维的，‍‍那显然分段对于用户来说是可见的，但是分页是操作系统管理的一个行为，对于用户来说不可见

　　我们还介绍了段表和页表的结构，还有原理，需要注意的是段页式管理中的段表‍‍和分段管理当中的段表结构是不太一样的，段页式管理当中段表由段号、‍‍页表、长度、页表存放地址这么三个信息组成，但是在分段管理当中，由段号段的长度，‍‍还有段的起始地址这么三个信息组成，所以段表是不太一样的。‍‍但是页表的话和分页存储当中的‍‍页表的结构是相同的，都是由页号还有页面存放的内存块号来组成。

　　那之后我们介绍了地址变换的过程，‍‍比起分页和分段的地址变换过程来说，段页式管理需要查先查询段表，‍‍之后还需要再查询页表，‍‍并且在找到段表项之后，还需要对页表长度还有页号进行一个对比检查，‍‍看看页号是否已经越界。‍‍同学们需要理解这个过程，能够自己写出来他的地址变换过程到底是什么样的。‍‍

　　最后我们还分析了段页式管理当中访问一个逻辑地址所需要的访存次数。‍‍第一次访存需是需要查段表，第二次访存是查阅表，第三次访存才是访问目标内存单元。‍‍如果我们引入了快表机构之后，就可以以段号还有页浩作为关键字去查询快表，‍‍如果快表命中的话，那么仅需要一次缓存

　　![](https://image.peterjxl.com/blog/image-20221008220821-oytdnp7.png)​

　　‍

　　‍
