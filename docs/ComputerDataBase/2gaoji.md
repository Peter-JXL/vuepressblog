# 高级语法

# 概述

	按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为**一张数据表的表结构所符合的某种设计标准的级别**。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。

	数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。

接下来就对每一级范式进行一下解释，首先是**第一范式（1NF）。**

# 第一范式

符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。**1NF的定义为：符合1NF的关系中的每个属性都不可再分。表1**所示的情况，就不符合1NF的要求。

![image-20191104153305483](assets\image-20191104153305483.png)

表1

实际上，**1NF是所有关系型数据库的最基本要求**，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为**表2**的形式：

| 编号 | 品名 | 进货数量 | 销售数量 | 销售单价 | 备注 |
| ------ | ------ | ---------- | ---------- | ---------- | ------ |
|      |      |          |          |          |      |

	**1NF的定义为：符合1NF的关系中的每个属性都不可再分。**但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于**表3**中的设计：

| 学号       | 姓名   | 系名   | 系主任 | 课名       | 分数 |
| ------------ | -------- | -------- | -------- | ------------ | ------ |
| 1022211101 | 李小明 | 经济系 | 王强   | 高等数学   | 95   |
| 1022211101 | 李小明 | 经济系 | 王强   | 大学英语   | 87   |
| 1022211101 | 李小明 | 经济系 | 王强   | 普通化学   | 76   |
| 1022211102 | 张莉莉 | 经济系 | 王强   | 高等数学   | 72   |
| 1022211102 | 张莉莉 | 经济系 | 王强   | 大学英语   | 98   |
| 1022211102 | 张莉莉 | 经济系 | 王强   | 计算机基础 | 88   |
| 1022511101 | 高芳芳 | 法律系 | 刘玲   | 高等数学   | 82   |
| 1022511101 | 高芳芳 | 法律系 | 刘玲   | 法学基础   | 82   |

表3

1. 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大
2. 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常

    注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。

    注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。

    3. 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常。
    4. 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——修改异常

		正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。

# 第二范式

	**2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。接下来对这句话中涉及到的四个概念——**“函数依赖”**、**“码”**、**“非主属性”**、与**“部分函数依赖”**进行一下解释。

		**函数依赖**    我们可以这么理解（但并不是特别严格的定义）：**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y**。

		也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

       例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说**姓名函数依赖于学号**，写作 **学号 → 姓名**。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。 表中其他的函数依赖关系还有如：

* 系名 → 系主任
* 学号 → 系主任
* （学号，课名） → 分数

但以下函数依赖关系则不成立：

* 学号 → 课名
* 学号 → 分数
* 课名 → 系主任
* （学号，课名） → 姓名